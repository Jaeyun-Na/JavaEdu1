package kr.co.OOP;

public class objectOriented_7_배열과ArrayList {
	
	/*
	 *	7-1 [배열이란?]
	 *
	 *-자료를 순차적으로 관리하는 구조, 배열-
	 *
	 *학교에 학생이 100명이 있음. 이학생 100명의 학번을 어떻게 관리할 수 있을까? 학번의 자료형을 정수하고 하면 학생이 100일 때 int studentID1, int studentID2, int studentID3, ......
	 *int studentID100 이렇게 변수 100개를 선언해서 사용해야함. 그런데 학번에 대한 여러 개 변수들을 일일이 쓰는것은 귀찮고 번거로움.
	 *이때 사용하는 자료형이 배열(Array)임. 배열은 자료 구조의 가장 기초 내용임.
	 *
	 *배열을 사용하면 자료형이 같은 자료 여러 개를 한 번에 관리할 수 있음.
	 *
	 *-배열 선언과 초기화-
	 * 
	 * 배열을 사용하려면 먼저 배열을 선언해야함.
	 * 배열도 변슈ㅜ와 마찬가지로 자료형을 함께 선언함. 배열을 선언하는 문법은 아래와 같다.
	 * 
	 * 자료형[] 배열이름 = new 자료형[개수];
	 * 자료형 배열이름[] = new 자료형[개수];
	 * 
	 * 배열을 이루는 각각의 자료를 배열 요소하고함. 배열 요소는 자료형이 모두 같음.
	 * 먼저 저장하려는 자료의 성격에 맞게 자료형을 정하고 선언하려는 배열 요소 개수만큼 [] 안에 적음.
	 * new 예약어는 배열을 사로 만들라는 의미임. 여기서는 '배열형' 자료란 의미로 변수 앞에 '자료형[]'을 사용하는  '자료형[] 변수이름 = new 자료형[개수];' 선언방식을 사용.
	 * 이 선언 방식을 사용해서 앞에서 이야기한 학생들의 학번을 배열로 선언해봄.
	 */
	  	int[] studentIDs = new int[10];
	 /* 
	 * 위 문장은 int형 요소가 10개인 배열을 선언한 것임. 이렇게 선언했을 때 메모리 상태를 그림으로 나타내면 다음과 같음.
	 * 
	 * 
	 * 										배열 길이(length)
	 * 											10개
	 * <---------------------------------------------------------------------------------------->
	 *|	4 바이트	|		|		|		|		|		|		|		|		|		|		|
	 * ----------------------------------------------------------------------------------------
	 * 											40 바이트
	 * 										(배열 전체 바이트)
	 * 
	 * 배열을 선언하면 선언한 자료형과 배열 길이에 따라 메모리가 할당됨. 위 그림을 보면 자료형이 int형이므로 배열 요소를 저장할 수 있는 공간의 크기는 전부 4바이트로 동일함.
	 * 배열 요소를 저장할 수 있는 공간이 총 10개이므로 이 배열을 위해 총 40바이트의 메모리가 할당 되는것 임.
	 * 
	 * 배열 초기화 하기
	 * 
	 * 자바에서 배열을 선언하면 그와 동시에 각 요소의 값이 초기화 됨. 배열의 자료형에 따라 정수는 0, 실수는 0.0, 객체 배열은 null로 초기화되며, 다음처럼 배열 선언과 동시에 특정 값으로 초기화할 수도 있음.
	 * 배열이 초기화 요소의 개수만큼 생성되므로 []안의 개수는 생략함.
	 * 
	 * int[] studentIDs = new int[] {101, 102, 103};		// 개수는 생략함
	 * 
	 * 다음과 같이 값을 넣어 초기화할 때 [] 안에 개수를 쓰면 오류가 발생함.
	 * 
	 * int[] studentIDs = new int[3] {101, 102, 103};		// 요류 발생
	 * 
	 * 선언과 동시에 초기화할 떄 다음과 같이 new int[] 부분을 생략할 수도 있음. int형 요소가 3개인 배열을 생성한다는 의미이므로 new int[]를 생략해도 됨
	 * 
	 * int[] studentIDs = {101, 102, 103}; 					// int형 요소가 3개인 배열 생성
	 *  
	 * 하지만 다음과 같이 배열의 자료형을 먼저 선언하고 초기화하는 경우에는 new int[]를 생략할 수 없음
	 * 
	 * int[] studentIDs;									// 배열 자료형 선언
	 * studentIDs = new int[] {101, 102, 103};				// new int[]를 생략할 수 없음
	 * 
	 * 
	 * -배열 사용하기-
	 * 
	 * 선언한 배열의 각 요소에 값을 넣을 때나 배열 요소에 있는 값을 가져올 때는 []를 사용함. 만약 배열의 첫 번째 요소에 값 10을 저장한다면 다음처럼 코드를 작성함.
	 * 
	 * studentIDs[0] = 10;									// 배열의 첫 번째 요소에 값 10을 저장
	 * 
	 * 첫 번째 요소에 값을 저장했다는데 []안에는 0이 있음. 위 코드에 대해 자세히 살펴보자.
	 * 
	 * 인덱스 연산자 []
	 * 
	 * []는 배열을 처음 선언할 때 사용한 연산자임. 배열 이름에 []를 사용하는것을 인덱스 연산이라고 함. 인덱스 연산자의 기능을 배열 요소가 저장된 메모리 위치를 찾아 주는 역할임.
	 * 변수 이름으로 변수가 저장된 메모리 위치를 찾는 것처럼, 배열에서 [i] 인덱스 연산을 하면 i번째 요소의 위치를 찾아 해당 위치의 메모리에 값을 넣거나 이미 저장되어 있는 값을 가져와서 사용할 수 있음.
	 * 예를 들어 int형으로 선언한 num 배열의 네번째 요소에 값 25를 저장하고, 그 값을 가져와 int형 변수 age에 저장한다면 밑과 같음
	 * 
	 * num 배열
	 *	[	][	][	][ 25 ][	][	][	][	]
	 * 	num[3]	=	25;
	 * num 배열의 네 번째 요소에 값 25를 저장
	 * ex)배열은 첫번쨰는 0,1,2,3....이렇게 진행됨
	 * 
	 * 
	 * 	age						num 배열
	 * [	]	<----	[	][	][	][ 25 ][	][	][	][	]
	 * 	age = num[3];
	 * age 변수에 num 배열의 네번째 요소값을 저장
	 * 
	 * *배열의 물리적 위치와 논리적 위치는 같음.
	 * 물리적(physical) 위치란 배열이 메모리에서 실제 저장되는 곳을 의미, 논리적(logical) 위치란 이론상 배열 위치를 의미함.
	 * 배열은 요소 10갸를 선언하면 사용하는 실제 값도 바로 이웃한 메모리에 놓임. 즉 '5 다음에 10이 있다'는 논리적 순서와 실제 메모리를 살펴보면 값 5가 놓인 메모리 주소에서 4바이트(int형 크기) 메모리 주소에 값 10이 놓임.
	 * 
	 * 
	 * -배열 순서는 0번부터-
	 * 배열 길이(처음에 선언한 배열 전체 요소 개수)가 n이라고 하면, ㅐ병ㄹ 순서는 0번부터 n-1번까지임.
	 * 0번 요소를 배열의 찻 번째 요소라고함. 이해를 돋기 위해 정수 10개를 정장할 배열을 선언하고 각 요소를 값 1분터 10까지 초기화한 후 for 반복문을 사용하여 배열 요소 값을 하나씩 출력해보자
	 * (array -> ArrayTest.java)
	 * 
	 * 5행에서 int형 배열 num을 선언하고 1부터 10까지의 값으로 초기화 아였음. 초기화가 끝난 num배열은 다음과 같음
	 * 
	 * 	 1			2			3			4			5			6			7			8			9			10
	 * num[0]	  num[1]	  num[2]	  num[3]	  num[4]	  num[5]	  num[6]	  num[7]	  num[8]	  num[9]
	 * 
	 * 배열 요소를 하나씩 가져와 출력하기 위해 7행에서 for반복문을 사용했음. 배열의 첫 번째 요소 인덱스는 0부터 시작함.
	 * 
	 * 0부터 9까지 반복이면 조건식을 i<=9로 쓰는것이 더 좋은게 아닌가??
	 * 0부터9까지 반복할 때는 일반적으로 for(int = int = 0; i<10; i++)문장을 사용함. 여기서 의문이 드는건 배열 요고사 10개일 떄 0부터 9까지의 값으로 각 배열 요소가 만들어진다고 했으니
	 * for(int = int = 0; i<=9; i++)라고 써야하지 않을까 하는 것임. 물론 이렇게 해도 경과 값은 같지만, 프로그래밍을 할 때는 [i <= 9]보다 [i < 10]으로 쓰는 것을 선호함.
	 * 왜냐하면 10이 배열 길이이므로 10으로 쓰는 것이 훨씬 직관적이기 때문. 즉 처음에 선언한 전체 배열 요소의 개수가 n개일 때 배열 요소의 인덱스는 0부터 n-1까지 만들어지지만 반복문은 [i < n]과 같이 사용하는 것이 코드를 직관적으로 이래하는 데 도움이 됨.
	 * 
	 * 자바의 배열은 배열 길이를 나타내는 length 속성을 가짐. 자바에서 배열 길이는 처음에 선언한 배열의 전체 요소 개수를 의미함. 전체 길이를 알고 싶은 배열 이름 뒤에 도트(.)연산자를 붙이고 length 속성을 쓰면 배열 길이를 반환함.
	 * for문의 조건에서 언만큼 반복할지 경정해야 하는데, 배열 요소 끝까지 반복하기 위해 배열 전체 길이(length)를 넣음.
	 * 따라서 num.length 값은 10이 됨. 이렇게 배열 전체 길이만큼 수행문을 반복해야 할 때는 숫자를 직접 사용하는 것보다 length 속성을 사용하는 것이 좋음.
	 * 
	 * 실습한 예제의 main()함수에 int sum = 0;을 작성하고, 8행 코드를 수정하여 배열의 모든 요소 합을 계산하는 프로그램을 만들어 보자.
	 * 
	 * -전체 배열 길이와 유효한 요소 값-
	 * 우리가 배열을 사용할 때 처음 선언한 배열 길이만큼 값을 저장해서 사용하는 경우는 많징 낳음. 따라서 전체 배열 길이와 현재 배열에 유효한 값이 저장되어 있는 배열 요소 개수가 같다고 혼동하면 안됨.
	 * (ArrayTest2.java)
	 * 
	 * double형으로 길이가 5인 배열을 선언함. 자바에서 정수 배열과 실수 배열을 별도로 초기화하지 않고 선언하면 배열의 요소 값은 0으로 초기화됨.
	 * 7~9행을 보면 배열의 첫번째 요소(data[0])부터 세 번째 요소(data[2])까지만 값을 저장했음. 11행 for문에서 i가 0부터 배열 길이인data.length 미만까지 반복하며 배열에 저장된 요소 값을 출력함.
	 * 배열의 네 번쨰 요소와 다섯 번쨰 요소에는 값을 저장하지 않았기 때문에 0이 출력되는 것을 알 수 있음. 즉 배열의 세 번째 요소까지만 유효한 값이 저장된 것임. 만약 ArrayTest2 코드에서 유효한 값이 저장된 배열 요소만 정확히 출력하려면 새로운 변수를 선언하고 배열
	 * 요소 순서대로 값을 저장할 때마다 그 변수 값을 증가시킴. 그리고 반복문 종료 조건으로 배열의 length 속성이 아닌 해당 변수를 사용하면 됨.
	 * 그러면 유효한 값이 저장된 배열 요소까지만 출력하는 프로그램을 만들어 보자.
	 * (ArrayTest3.java)
	 * 
	 * 6행에 유효한 값이 저장된 배열 요소 개수를 저장할 size 변수를 선언했음. 배열 요소에 순서대로 값을 저장할 때마다 size 변수의 값을 하나씩 증가시킴. 즉 유효한 값을 저장하고 있는 배열 요소 개수를 알 수 있는 것임. 따라서 12행 반복문은 전체 배열 길이만큼
	 * 반복하는 게 아니라 유료한 요소 개수만큼만 반복함.
	 * 
	 *  문자 저장 배열 만들기
	 *  
	 * 문자를 저장하는 배열도 한번 생각해보자. 문자 자료형 배열을 만들고 알파벳 대문자를 A부터 Z까지 저장한 후 각 요소 값을 알파벳 문자와 정수 값(아스키 코드 값)으로 출력해 보자.
	 * 문자 자료형 배열은 char[]로 선언해야함.
	 * (CharArray.java)
	 *  
	 * 5행에서  대문자 알파벳 26개를 저장하기 위해 문자형 배열을 선언하고, 8행에서 for문을 사용해 각 배열 요소에 알파벳 문자를 저장하였음. 각 알파벳 문자는 실제 메모리에 아스키 코드 값으로 저장되기 때문에 ch값에 1을 더하면(ch++) 1만큼 증가한 값이 배열에 저잠됨.
	 *  
	 *  
	 * 
	 * 						i :		0		 1		  2		 ...	24			25	
	 * alphabets[i] = ch;
	 * 						ch:  'A'(65)  'B'(66)  'C'(67)		  'Y'(89)	 'Z'(90)
	 *  
	 *  
	 * 12행의 for문은 alphabets 배열에 저장된 알파벳 문자와 그 문자에 해당하는 아스키 코드 값을 반복하여 출력함. 13행의 (int)alphabets[i] 문장에서 형 변환 연산지 (int)는 배열에 저장된char형 문자를 int형 정수로 변환함.
	 *  
	 *  
	 * 	객체 배열 사용하기
	 * 
	 * 참조 자료형으로 선언하는 객체 배열에 대해 알라보자. 동일한 기본 자요형(int 등) 변수 여러 개를 배열로 사용할 수 있듯이 참조 자료형 변수도 여러 개를 배열로 사용할 수 있음.
	 * 객체 배열은 int나 char 등 기본 자료형 배열과 사용 방법이 조금 다름.
	 * Book 클래스를 만들고 이클래스로 객체 배열을 만들어 보자.
	 * (Book.java)
	 *  
	 * Book 클래스는 책 이름과 저자를 멤버 변수로 가지는 클래스임. 디폴트 생성자 외에도 책 이름과 저자 이름을 매개변수로 받는 생성자를 하나 더 구형했음. 다른 코드에서 이클래스를 사용할 때 멤버 변수 값을 가져오거나 지정할 수 있도록 get(),set()메서드도 구현 함.
	 * 마지막으로 책의 정보를 출력해 주는 showBookInfo()메서드까지 구현.
	 * 
	 * 도서관에 책이 5권 있다고 가정. Book클래스를 사용하여 책 5권을 객체 배열로 만들어 보자.
	 * (BookArray.java)
	 * 이 코드에서 우리가 이해해야 할 부분은 8행 Book[] library = new Book[5]; 문장임.
	 * 코드의 내용만 보면 Book 인스턴스 5개가 생성된 것처럼 보임. 하지만 Book 인스턴스 5개가 바로 생성되는 것은 아님.
	 * 이떄 만들어지는 것은  무엇일까? 인스턴스를 생성하면 그 인스턴스를 가리키는 주소 값이 있음. Book[] library = new Book[5];는 각각의 Book 인스턴스 주소 값을 감을 공간 5개를 생성하는 문장임.
	 * 즉 이 문장을 생행하면 다름 그림 처럼 Book주소 값을 담을 공간이 5개 만들어지고 자동으로 각 공간은 '비어있다'는 의미의 null값으로 초기화 됨.
	 * 
	 *  	library[0]	 	library[1]	 	library[2]	 	library[3]	 	library[4]
	 *  	   null  	      null  	      null  	      null  	      null
	 *  
	 * 이제 각 배열 요소에 인스턴스를 생성해 넣어 보자. Book 크래스에 쿠현한 생성자를 사용해보자.
	 * (BookArray2.java)
	 * 
	 * 배열의 각 요소에 Book 인스턴스를 만들어 직접 저장했음. 위 출력 화면을 보면 각 인스턴스가 모두 잘 생성되었음을 알 수 있음.
	 * 20~21행의 출력 내용은 각 배열 요소가 가지고 있는 인스턴스 주소값임.
	 * 
	 * 코딩 예제- 객체 배열만들어 활용하기.
	 * 학생클래스 Student를 만들고 멤버 변수로 studentID, name을 선언. showStudentInfo()메서드를 만들어 studentID와 name 값을 출력함.
	 * StudentArray 클래스에서 Student 3명의 배열을 만들고 Student를 생성하여 저장한 후 for문을 사용하여 Student 정보를 출력함.
	 * (student.java, StudentArray.java)
	 * 
	 * 	배열 복사하기
	 * 
	 * 기존 배열과 자료형 및 배열 크기가 똑같은 배열을 새로 만들거나 배열의 모든 요소에 자료가 꽉 차서 더 큰 배열을 만들어 기존 배열에 저장된 자료를 가져오려 할 때 배열을 복사함.
	 * 배열을 복사하는 방법은 두 가지가 있음. 첫번째는 기존 배열과 배열 길이가 같거나 더 긴 배열을 만들고 for문을 사용하여 각 요소 값을 반복해서 복사하는 방법.
	 * 이 코드는 간단하기 떄문에 생략. 두 번째는 System.arraycopy() 메서드를 사용하는 방법임. System.arraycopy() 메서드를 사용하는 방법임.
	 * System.arraycopy(src, srcPos, dest, destPos, length) 메서드에서 각 매개변수 의미는 다음과 같다.
	 * 
	 * 		매개변수				설명
	 *		 src		복사할 배열 이름
	 *		srcPos		복사할 배열의 첫 번째 위치
	 *		dest		복사해서 붙여 넣을 대상 배열 이름
	 *	   destPos		복사해서 대상 배열에 붙여 넣기를 시작할 첫 번째 위치
	 *	   length		src에서 dest로 자료를 복사할 요소 개수 
	 *
	 * System.arraycopy() 메서드를 사용한 다음 예제를 살펴봅시다.
	 * (ArrayCopy.java)
	 * 
	 * 예제를 보면 array1 배열에서 array2 배열로  요소 값을 복사함. array1 배열의 요소 0번(첫 번째 요소)부터 4개를 복사해서 대상 배열 array2의 요소 1번(두번째 요소)부터 붙여 넣음.
	 * 출력 결과를 보면 array2 배열의 첫 번째 요소 값인 1을 제외하고 나머지 요소 값만 변경된 것을 알 수 있음. 이때 복사할 대상 배열의 전제 길이가 복사할 요소 개수보다 작다면 요류가 남.
	 * 즉 위 예제에서는 요소 4개를 복사 했지만, 만일 요소 5개를 복사한다고 코드를 수정하면 array2 배열 길이보다 요소 개수가 많아지므로 요류가 발생함.
	 *
	 *	-객체 배열 복사하기-
	 * 객체 배열도 마찬가지로 복사해서 사용할 수 있음. 간단하게 String 클래스를 사용한예를 살펴보면 array 패키기에 Book 클래스는 이미 만들어 두었으므로, 같은 패키지에 다음BbjectCopy1 클래스를 추가호 만들어 진항함.
	 * (ObjectCopy1.java)
	 * 
	 * 예제 코드의 출력 결과를 보면 bookArray1 배열에서 bookArray2 배열로 배열로 요소 값이 잘 복사된 것을 알 수 있음.
	 * bookArray2 배열의 인스턴스를 따로 만들지 않았는데 각 요소 값이 잘 출력되고 있음.
	 * 
	 * 	-얕은 복사-
	 * 앞 예제에서 배열을 복사해 출력하기 전 bookarray1 배열 요소 값 하나를 변경해보자.
	 * (ObjectCopy2.java)
	 * 
	 * 출력 화면을 보면 20~21행에서 bookArray1 배열 요소 값을 변경했는데 bookArray2 배열 요소 값도 변경된 것을 알 수 있음. 객체 배열의 요소에 저장된 값은 인스턴스 자체가 아니고 인스턴스의 주소 값이기 때문.
	 * 따라서 객체 배열을 복사할 때 인스넡스를 따로 생성하는게 아니라 기존 인스턴스의 주소 값만 복사함. 결국 두 배열의 서로 다은 요소가 같은 인스턴스를 가리키고 있음으로 복사되는 배열의 인스턴스 값이 변경되면 두배열 모두 영향을 받는 것임.
	 * 
	 * 			bookArray1[0]			bookArray1[1]			bookArray1[2]
	 * 			태백산맥. 조정래		   데미안, 헤르만 헤세		  다 빈치 코드, 댄 브라운
	 * 			bookArray2[0]			bookArray2[1]			bookArray2[2]			 
	 * 
	 * 20~21행 코드처럼 bookArray1의 첫 번째 요소 값을 경경하면 다음처럼 bookArray2의 첫 번째 요소 값도 영향을 받는것임.
	 * 
	 * 			bookArray1[0]			bookArray1[1]			bookArray1[2]
	 * 		(변경)개미. 베릅나브 베르베르	   데미안, 헤르만 헤세		  다 빈치 코드, 댄 브라운
	 * 			bookArray2[0]			bookArray2[1]			bookArray2[2]			 
	 * 
	 * 이와 같은 복사를 주소 값만 복사한다고 해서 '앝은 복사(shallow copy)'라고 함. 인스턴스 값만 복사하고, bookArray1 배열과배열의 각 요소가 서로 다은 인스턴스를 가리키게 하려면??
	 * 
	 * 	-깊은 복사-
	 * 
	 * 반복문을 사용하건 System.arraycopy() 메서드를 사용하건 객체 배열을 복사하면 항상 인스턴스 주소가 복사됨. 대부분의 경우는 이렇게 해도 문제가 없지만, 인스턴스를 따로 관리하고 싶다면 직접 인스턴스를 만들고 그 값을 복사해야함.
	 * 이를 '깊은 복사(deep copy)'라고 함.
	 * 
	 * 다음 예제는 복사할 배열에 인스턴스를 따로 생선한 후 요소 값을 복사함. 이렇게 하면 복사한 배열 요소는 기존 베열 요소와 서로 닫른 인스턴스를 가리키므로 기존 배열의 요소값이 변경 되어도 영향을 받지 않음.
	 * (ObjectCopy3.java)
	 * 
	 * 예제처럼 깊은 복사를 할 경우 메모리 그림은 다음과 같음
	 
	 * 		bookArray1[0]			bookArray1[1]			bookArray1[2]
	 *		나목, 박완서			   데미안, 헤르만 헤세		  다 빈치 코드, 댄 브라운
	 *
	 * 		태백산맥. 조정래		   데미안, 헤르만 헤세		  다 빈치 코드, 댄 브라운
	 * 		bookArray2[0]			bookArray2[1]			bookArray2[2]	
	 * 
	 *  -향상된 for문과 배열-
	 * 자바 5부터 제공되는 향상된 for문은 배열의 처음에서 끝까지 모든 요소를 참조할 때 사용하면 편리한 반복문임.
	 * 향상된 for문은 배열 요소 값을 순서대로 하나씩 가져와서 ㅕㄴ수에 대이함. 따로 초기화와 종료 조건이 없기 떄문에 모든 배열의 시작 요소부터 끝 요소까지 실행한다.
	 * (EnhancedForLoop.java)
	 * 
	 * String형으로 선언된 strArray 배열에 문자열 5개르 ㄹ저장함.
	 * 향상된 for문을 사용해 string형 lang ㅂㅂ볍ㄴ수에 strString 배열 요소 값을 순서대로 가져와 대임. lang 변수를 출력하면 strArray 배열에 저장된 값이 순서대로 출력됨.
	 * 
	 * 예문- 향상된 for문을 사용 int배열 [numArray]의 요소 갑ㅄ을 순서대로 하나씩 가져와서 int형 변수 [number]에 대입하는 코드를 만들자.
	 * int[] numArray = new int[]{1,2,3,4,5,,,6,7,8,,9,10};
	 * 	for(int number : numArray){	}
	 * 
	 */
	  	
	  	
	  	

	
	
}
