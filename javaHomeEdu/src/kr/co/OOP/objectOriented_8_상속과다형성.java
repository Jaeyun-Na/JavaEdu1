package kr.co.OOP;

import polymorlphism.Customer;

public class objectOriented_8_상속과다형성 {

	/*
	 *	8-1	상속이란?
	 * 	
	 * 	객체 지향 프로그래밍의 중요한 특징 중 하나가 상속(inheritance)임. 상속은 우리가 일반적으로 알 듯 무엇인가를 물려받는다는 의미임.
	 * 	일례로 부묘가 자식에게 물려주는 재산을 상속이라함. 부모에게 재산을 상속받으면 상속받은 재산을 자신의 것으로 사용할 수 있음.
	 * 	객체 지향 프로그램에서도 마찬가지임. B 클래스가 A 클래스를 상속받으면 B 클래스는 A 클래스의 멤버 변수와 메서드를 사용할 수 있음.
	 * 	객체 지향 프로그램은 유지 보수하기 편하고 프로그램을 수정하거나 새로운 내욜을 추가하는 것이 유연한데, 그 기반이 되는 기술이 바로 상속임.
	 * 
	 * 	-클래스의 상속
	 * 
	 * 상속을 구체적으로 학습하기 전에 자바에서 상속과 관련하여사용하는 용어롸 문법에 대해 알아보자.
	 * B 클래스가 A 클래스에서 상속받는다고 할 때 다음과 같다.
	 * 
	 * 	(상위 클래스)	| A 클래스 |
	 *	 				^
	 *					|
	 * 					----------- A 클래스가 B 클래스에게 상속한다 = B 클래스가 A 클래스를 상속받는다.
	 * 					|
	 * 	(하위 클래스)	| B 클래스 |
	 * 
	 * 상속을 하는 클래스에서 상속을 받는 클래스로 화살표가 갈 것 같지만, 클래스 간 상 속을 표현할 때는 위 그림에서 표현한 것처럼 상속받는 클래스에서 상속하는 클래스로  화살표가 가므로 헷갈리면 안 됨.
	 * 부모 클래스를 '상위 클래스', 자식 클래스를 '하위 클래스'라고함.
	 * 
	 * 클래스 상속 문법
	 * 자바 문법으로 상속을 구현할 때는 extends 예약어를 사용함. 이때 사용하는 extends 예약어는 '연장, 확장하다'의 의미. 즈 A가 가지고 있는 속성이나 기능을 추가로 확장하여 B 클래스를 구현한다는 뜻.
	 * 그러면 일반적인 클래스 A에서 더 구체적인 클래스 B가 구현됨.
	 * class B extands A{
	 * }
	 * 위 코드는 'B 클래스가 A 클래스를 상속받는다'라고 함.
	 * 
	 * 	포유류(원숭이, 고래, 사자... 등) 	<--				 사람
	 * 	class Mammal{						class Human extends Mammal{
	 * 		...						<--			...
	 * 	}									 }
	 * 
	 * 포유류는 사람보다 일반적인 개념임. 즉 사람은 포유류의 특징과 기능을 기본으로 더 많거나 다른 특징과 기능을 가지고 있음. 이렇게 상속 관계에서는 상위 클래스가 하위 클래스보다 일반적인 개념이고, 하위 클래스는 상위 클래스보다
	 * 구체적인 클래스가 됨. 
	 * 
	 * 	-상속을 사용하여 고객 관리 프로그램 구현하기
	 * 
	 * 회사에서 고객 정보를 가지고 맞춤 서비스를 제공하기 위해 고게ㅐㄱ 관리 프로그램으로 구현하려고 함. 그러면 먼저 고객 클래스가 있어야함 고객 클래스를 구현하려면 클래스 속성을 멤버 변수로 선언하면 됨.
	 * 이 예제에서는 고객 아이디, 이름, 고객 등급, 보너스 포인트, 보너스 포인트 적립 비율을 속성으로 선언.
	 * (inheritance - Customer.java)
	 * 
	 * 예제에서 사용한 멤버 변수를 살펴보면 다음과 같음
	 * 
	 * 	customerID		고객 아이디
	 *	customerName	고객 이름
	 *	customerGrade	고객 등급 - 기본생성자에서 지정되는 기본 등급은 SILVER임.
	 *	bonusPoint		고객의 보너스 포인트 - 고객이 제품을 구매할 경우 누적되는 보너스 포인트임.
	 *	bonusRatio		보너스 포인트 적립 비율 - 고객이 제품을 구매할 때 구매 금액의 일정 비율이 보너스포인트로 적립됨. 이때 계산되는 적립 비율임.
	 * 		   							  - 기본 생성자에서 지정되는 적입 비율은 1%dla wmr 10,000월짜리를 사면 100원이 적립됨.
	 * 
	 * 모든 멤버 변수를 반드시 private으로 선언할 필요 없음. 필요에 따라 멤버 변수나 메서드를 외부에 노출하지 않을 목적일 때 private으로 선언함. 예제에서 사용한 메서드.
	 * 
	 * Customer()			기본 생성자임. 고객 한명이 새로 생성되면 customerGrade는 SILVER이고, bonusPoint는 1%로 지정됨.
	 * calcPrice()			제품에 대해 지불해야 하는 금액을 계산하여 반환됨. 할인되지 않는 경우 가격을 그대로 반환함. 그리고 가격에 대해 보너스 포인트 비율을 적용하여 보너스 포인트를 적립함.
	 * showCustomerInfo()	고객 정보를 출력함. 고객 이름과 등급, 현재 적입된 포인트를 보여줌.
	 * 
	 * 새로운 고객 등급이 필요한 경우
	 * ------------------------------------------------------------------------------------------------------------------------------
	 * 예제 시나리오
	 * 고객이 점점 늘어나고 판매도 많아지다보니 단곡 고객이 생김. 단골 고객은 회사 매출에 많은 기여를 하는 우수 고객임. 이 우수 고객에서 좋은 혜택을 주고 싶음.
	 * 우수 고객 등급은 VIP이고, 다음과 같은 혜택을 제공함.
	 * 	-제품을 살 때는 항상 10% 할인해 줌.
	 * 	-보너스 포인트를 5% 적입해 줌.
	 * 	-담당 전문 상담원을 배정해 줌.
	 * ------------------------------------------------------------------------------------------------------------------------------
	 * 
	 * 위 같은 요구 사항을 구현하는 방법은 무엇일까. 이미 Customer 클래스가 존재하므로 Customer 클래스에 VIP 고객에 필요한 변수와 메서드까지 함께 포함하여 구현. 하지만 이렇게 구현하게되면 Customer 클래스의 코드가 복잡해짐.
	 * 게다가 일반 고객의 인스턴스를 생성할 때는 VIP 고객과 관련된 기능은 전혀 필요 없는데 VIP 고객의 내용까지 같이 생성되어 낭비가 발생. 이러한 경우는 VIPCustomer 크래스를 따로 만드는것이 좀음.
	 * (inheritance - VIPCustomer.java)
	 * 
	 * 클래스를 만들고 보니 앞에서 만든 Customer 클래스와 겹치는 멤버 변수와 메서드가 보임. CalcPrice() 메서드는 이름은 같지만 구현 내용은 다름. VIP 고객도 고객임. 다만 일반 고객에게 제공하는 혜택을 기본으로 제공하고
	 * 추가 속성과 메서드가 있는검. 이건 경우사 상속을 사용함.
	 * 즉 CUstomer 클래스에 일반 고객의 속성과 기능이 이미 구현되어 있기 떄문에 VIPCustomer 클래스는 Customer 클래스를 상속받고 VIP 고객에게 필요한 추가 속성과 기능을 구현하는것임. Customer 클래스를 상속한 VIPCustomer 클래스의 코드는 다음과 같다.
	 * (VIPCustomer.java -> 기존 변수 입력방식(주석 처리)이 아닌 상속방식으로 수정)
	 * 
	 * VIPCustomer 클래스의 코드가 간단해졌음. Customer 클래스에 이미 선언되어 있는 cusromerID, customerName, customerGrade, bonusPoint, bonusRatio 멤버 변수와 calcPrice(), showCustomerInfo() 메서드는 상속을 받아서 사용할 것이기 때문에 구현하지 않음.
	 * 해당 코드에서는 두 가지 문제가 있음. 첫째, customerGrade 변수에서 오류가 발생. 상위 클래스에 선언한 변수인데 오류가 발생한 이류는 private 변수이기 때문. 해당 변수는 외부클래스에서 사용할 수 없음.
	 * 두번째는 VIP 고객에서 제공하는 혜택인 할인율 과 세일 가격을 어떻게 적용할지 구현하지 않았다는 점임.-> 이부분은 8-3 메서드 오버라이딩에서.
	 * 
	 * 상위 클래스 변수를 사용하기 위한 protected 예약어
	 * customerGrade 변수에서 발생하는 오류부터 수정해보자. 이 오류는 상위 클래스에 선언한 customerGrade가 private 변수이기 때문에 발생. 상위 클래스에 작성한 변수나 메서드 중 외부 클래스에서 사용할 수 없지만 하위 클래스에서는 사용할 수 있도록 지정하는 예약어가
	 * 바로 protected임. 상위받은 하위 클래스에서는 public처럼 사용할 수 있는 검임. 즉 protected는 상속된 하위 클래스를 제외한 나머지 외부 클래스에서는 private와 동일한 역할을 함.
	 * 
	 * Customer 클래스에 있는 private 변수를 다른 하위 크래스에서도 사용할 수 있도록 protected로 바꿔보겠음. 그리고 protected로 선언한 customerID, customerName, customerGrade 변수를 사용하기 위해 get(), set() 메서드를 추가해보자.
	 * (Customer.java - private 변수를 protected로 변경, get(),set() 생성)
	 * 
	 * protected 예약어로 선언한 변수는 외부 클래스에는 private 변수처럼 get() 메서드를 사용해 값을 가져올 수 있고, set() 메서드를 사용해 값을 지정할 수 있음. customer 클레스를 상속받은 VIPCustomer 클래스는 protected로 선언한 변수를 상속받게 되고,
	 * 나머지 public 메서드도 상속받아 사용할 수 있음. 위와 같이 protected로 선언하면 VIPCustomer 부분의 오류는 사라짐.
	 * 
	 * 테스트 프로그램 실행하기
	 * 간단한 테스트 프로그램을 만들어 두 클래스를 생성해 보자
	 * ----------------------------------------------------------------------------------------------------------
	 * 예제 시나리오
	 * 일반 고객 1명, VIP 고객 1명이 있음. 일반 고객의 이름은 이순신, ID는 10010, 현재 보유 보너스 포인트 1000점.
	 * VIP 고객의 이름은 김유신, ID는 10020, 현재 보유 보너스 포인트는 10000점
	 * ----------------------------------------------------------------------------------------------------------
	 * 
	 * 새로운 Customer 클래스를 생성하고 customerLee 참조 변수에 대입.
	 * VIPCustomer 클래스를 생성하고 customerKim 참조 변수에 대입.
	 * VIPCustomer가 Customer를 상속 했기 떄문에 고객 아이디, 고객 이름의 메서드를 사용할 수 있음. 두 고객의 속인인 아이디, 이름,보너스 포인트를 지정하고 showCustomerInfo() 메서드를 사용해 고객 정보를 출력함.
	 * 
	 * 8-2 상속에서 클래스 생성과 형 변환
	 * 
	 * 하위 클래스가 생성될 때 상위 클래스의 생성자가 먼저 호출됨. 상속 관계에서 클래스의 생성 과정을 사펴보면 하위 클래스가 상위 클래스의 변수와 메서드를 사용할 수 있는 이유와 하위 클래스가 상위 클래스의 자료형으로 형 변환을 할 수 있는 이유를 이해할 수 있음.
	 * 
	 * -하위 클래스가 생성되는 과정
	 * 상속을 받는 아휘 클래스는 상위 클래스의 변수와 메서드를 사용할 수 있음. 즉 CustomerTest 예제를 살펴보면, VIPCustomer 클래스로 선언한 customerKim 인스턴스는 상속받은 상위 클래스의 변수를 자기 것처럼 사용할 수 있음.
	 * 변수를 사용할 수 있다는 것은 그 변수를 저장하고 있는 메모리가 존재한다는 뜻. VIPCustomer 클래스의코드를 보면 해당 변수가 존재하지 않음. Customer 클래스를 상속받았을 뿐. 상속된 아휘 클래스가 생성되는 과정을 다시 생각해 볼 필요가 있음.
	 * 테스트를 하기 위해 Customer와 VIPCustomer 클래스 생성자에 출력문을 추가.
	 * (Customer.java, VIPCustomer.java -> 각각 출력문 추가)
	 * 
	 * CustomerTest2 출력값을 보면 상위 클래스의 Customer() 생성자가 먼저 호출되고 그다음에 VIPCustomer()가 호출되는 것을 할 수 있음. 정리하면 상위 클래스를 상속받은 하위 클래스가 생성될 때는 반드시 상위클래스가 먼저 호출됨. 상위 클래스 생성자가 호출될 때 상위 클래스의 멤버 변수가 메모리에 생성되는것임.
	 * 하위 클래스 VIPCustomer가 생성될 때 메모리 구조를 간다히 그려보면 다음과 같음.
	 * 
	 * 	  힙 메모리
	 * 	customerID		-
	 *  customerName	|
	 *  customerGarade	|--> Customer() 생성자 호출 -> Customer클래스의 멤버 변수가 메모리에 생성됨
	 *  bonusPoint		|
	 *  bonusRatio	    -
	 *  agentID			-
	 *  salesRatio		---> VIPCustomer() 생성자 호출 -> VIPCustomer 클래스의 멤버 변수가 메모리에 생성됨
	 *  
	 *  상위 클래스의 변수가 메모리에 먼저 생성되기 떄문에 하위 클래스에서도 이 값들을 모두 사용할 수 있음. 08-1에서 상위 클래스의 변수를 private으로 선언한 경우에 하위 클래스에서 해당 변수를 사용할 수 없었던 건은 단지 하위 클래스에서 접근할 수 없었을 분임.
	 *  지금까지는 하위 클래스가 생성될 떄 상위 클래스가 먼저 만들어진다는 것을 배웠음. 이제 어떤과정으로 상위 클래스가 생성되는지 알아보자.
	 *
	 * -부모를 부르는 예약어 super
	 * super 예약어는 하위 클래스에서 상위 클래스로 접근할 떄 사용함. 하위 클래스는 상위 클래스이 주소,(참조 값)을 알소 있음. 이 참조값을 가지고 있는 예약어가 바로 super
	 * this가 가기 자신의 참조 값을 가지고 있는 것과 같다고생각하면 됨. super는 상위 클래스의 생성자를 호출하는 데도 사용.
	 * 
	 * 상위 클래스 생성자 호출하기
	 * CustomerTest2.java 예제를 보면 VIPCustomer만 생성하였는데 Customer 상위 크래스도 생성된것을 할 수 있음. 하위 클래스 생성자만 호출했는데 상위 클래스 생성자가 호출되는 이유는 하위 클래스 생성자에서 super()를 자동 호출하기 때문임.
	 * super()를 호출하면 상위 클래스의 디폴트 생성자가 호출됨. 하위 클래스의 디폴트 생서자는 바이트 코드로 변환되기 전에 다음과 같이 코드가 자동으로 변경됨.
	 * (CustomerTest2.java)
	 * 
	 * super 예약어로 매개변수가 있는 생성자 호쿨하기
	 * 이런 경우를 생각해보자. Customer 클래스를 생성할 때 고객 ID와 이름을 반드시 지정해야 한다고 가정, 이런 경우에 set() 메서드로 값을 지정하는 것이 아니고, 새로운 생성자를 만들어서 매겨변수로 값을 전달받아야함.
	 * 즉 디폴트 생성자가 아닌 매개변수가 있는 생성자를 직접 구현해야함. Customer 클래스에 새로운 생성자를 추가하고, 기존의 디폴트 생성자는 삭제하거나 주석 처리해보자.
	 * (Customer.java)
	 * 
	 * Customer 클래스의  디퐁트 생성자를 없애고 새로운 생성자를 작성하면, Customer 클래스를 상속받은 VIPCustomer 클래스에서 오류가 발생함. 오류가 발생한 디폴트 생성자에 마우스를 오려 보면 다음과 같은 오류 메시지가 보임.
	 * Implicit super constructor  Customer() is undefined, Must explicitly invoke another constructor
	 * 이 오류 메시지는 묵시적으로 호출될 디폴트 생성자 Customer()가 정의되지 않았기 떄문에, 반드시 명싲적으로 다른 생성자를 호출해야 한다는뜻.
	 * 
	 * Customer 클래스를 새로 생성할 떄 고객 ID와 고객 이름을 반드시 지정하여 생성하기로했으니 VIPCustomer 클래스를 생성할 때도 이 값이 필요함. 그리고 VIP 고객만을 위한 상담원 ID까지 함께 지정해보자.
	 * 기존 VIPCustomer 클래스의 디폴트 생성자도 지우거나 주석 처리한 후 필요한 매개변수를 포함하는 새성자를 새로 작성해보자
	 * (VIPCustomer.java)
	 * 
	 * 새로운 생성자는 고객 ID, 고객 이름, 상담원 ID를 매개변수로 받음. super 예약어는 상위 클래스 생성자를 호출하는 역할을 하며, 3행 super(customerID, customerName); 문장으로 상위 클래스 생성자를 호출함.
	 * VIPCustomer(int customerID, String customerName, int agentID) 생성자의 코드가 실제로 실행되는 형태는 다음과 같음.
	 
	 * public VIPCustomer(int customerID, String customerName, int agentID) {
	 *	super(customerID, customerName);
	 *	customerGrade = "VIP";
	 *	bonusRatio = 0.05;
	 *	saleRatio = 0.1;
	 *	System.out.println("VIPCustomer() 생성자 호출");
	 *}
	 * 
	 * super()를 통해 Customer(int customerID, String customerName) 상위 클래스 생성자를 호출하고 코드 순서대로 멤버 변수가 초기화됨. 상위 클래스 생성자 호출이 끝나면 VIPCustomer 하위 클래스 생성자의 내부 코드 수행이 마무리됨.
	 * 
	 * ^ 하위 클래스가 생성될 때는 상위 클래스의 [생성자]가 먼저 호출됨.
	 * ^ 상위 클래스에 생성자 코드가 따로 없으면 [super()]로 상위 클래스의 디폴트 생성자가 자동으로 호출됨.
	 * ^ 상위 클래스에 디폴트 생성자가 없고 매개변수가 있는 생성자만 있을 경우 [super()]에 매개변수를 추가하여, 매개변수가 있는 상위 클래스의 생성자를 직접 호출해야함.
	 * 
	 * 상위 클래스의 멤버 변수나 메서드를 참조하는 super
	 * 상위 클래스에 선언한 멤버 변수나 메서드를 하위 클래스에서 참조할 때도 super를 사용함. this를 사용하여 자신의 멤버에 접근했던 것과 비슷. 예를 들어 VIPCustomer 클래스의 showVIPInfo() 메서드에서 상위 클래스의 showCustomerInfo() 메서드를 참조해
	 * 담당 상담원 아이디를 추가호 출력하려고 할 떄 다음과 같이 구현할 수 있음.
	 * 
	 * public String showVIPInfo(){
	 * 	return super.showCustomerInfo() + "담당 상담원 아이디는" + agentID + "입니다";
	 * }
	 * 
	 * super 예약어는 상위 클래스의 참조 값을 가지고 있으므로 위 코드처럼 사용하면 고객 정보를 출력하는 showCustomerInfo() 메서드를 새로 구현하지 않고 상위 클래스의 구현 내용을 활용할 수 있음.
	 * 물론 위 코드의 VIPInfo() 메서드에서는 굳이 super.showCustomerInfo()라고 호출하지 않아도 상위 클래스의 메서드가 잘 호출됨.
	 * 아직 배우지 않았지만 하위 클래스가 상위 클래스와 동일한 이름의 메서드를 수형하는 경우도 있음. 이러한 경우 하위 클래스에서 동일한 이르므이 상위 클래스 메서드를 사리킬 때 super.showCustomerInfo()라고 써야함.
	 * 
	 *  -상위 클래스로 묵시적 클래스 형 변환
	 *  
	 * 상속을 공부하면서 우리가 이해해야 하는 중요한 관계가 클래스 간의 형 변환임. 일단 Customer와 VIPCustomer의 관계를 생각해 보자. 개념 면에서 보면 상위 클래스인 Customer가 VIPCustomer보다 일반적인 개념이고,
	 * 기능 면에서 보면 VIPCustomer가 Customer보다 기능이 더 많음. 왜냐하면 상속받은 클래스는 상위 클래스 기능을 모두 사용할 수 있고 추가로 더 많은 기능을 구현하기 떄문.
	 *  
	 * 따라서 VIPCustomer는 VIPCustomer형이면서 동시에 Customer형이기도 함. 즉 VIPCustomer 클래스로 인스턴스를 생성할 때 이 인스턴스의 자료형을 Customer형으로 클래스 형 변환하여 선언할 수 있음.
	 * 왜냐하면 VIPCustomer 클래스는 Customer 클래스를 상속받았기 떄문임.
	 * 
	 * 선언된 클래스형							생성된 인스턴스의 클래스형
	 * (상위 클래스형)							  (하위 클래스형)
	 * 	Customer 		vc 		=		 new VIPCustomer();
	 * 
	 * 그러면 반대로 Customer로 인스턴스를 생성할 떄 VIPCustomer형으로 선언할 수 없음. 상위 클래스인 Customer가 VIPCustomer클래스의 기능을 다 가지고 있지 않음.
	 * 정리하자면, 모든 하위 클래스는 상위 클래스 가료형으로 형변환될 수 있지만, 그 역은 성립하지 않음. 따라서 아휘 클래스인 VIPCustomer는 상위 클래스 Customer형을 내포하고 있기 때문에 Customer형으로 형 변환할 수 있음.
	 * 하지만 그 역은 성립될수 없음.
	 * 
	 *  형 변환된 vc가 가르키는 것
	 * Customer vc = new VIPCustomer();에서 형 변환된 vc가 가리키는 것은 무엇일까? 메모리 그림을 샃펴보자
	 *
	 * 		힙 메모리
	 * 	  customerID	--
	 *    customerName	 |
	 *    customerGrade	 |-- 1) Customer() 생성자 호출
	 *    bonusPoint	 |	  -> Customer 클래스의 멤버 변수가 메모리에 생성됨
	 *    bounsRatio	--
	 *  ------------------- 
	 *    agentID		---- 2) VIPCustomer() 생성자 호출
	 *    salesRatio	_|	  -> VIPCustomer 클래스의 멤버 변수가 메모리에 생성됨
	 * 
	 * Customer vc = new VIPCustomer(); 문장이 싱행되면 VIPCustomer 생성자가 허출되므로 클래스 변수가 위와 같이 메모리에 만들어짐.
	 * 그런데 클래스의 자료형이 Customer로 한정됨. 클래스가 형 변환이 되었을 때는 선언한 클래스형에 기반하여 멤버 변수와 메서드에 접근할 수 있음. 따라서 이 vc 참조 변수가 가리킬 수 있는 변수와 메서드는 Customer 클래스의 멤버뿐임.
	 * 이클랩스에서 vc변수에서 ctrl+spacebar를 눌러 보면 vc 참조 변수가 접근할 수 있는 변수와 메서드가 나타남.
	 * 
	 * 클래스 형 변환을 사용하는 이유는 '8-03 메서드 오버라이팅'과 '8-03 다형성'에서 자세히 다룸.
	 * 여기서는 일단 하위 클래스의 인스턴스가 상위 클래스로 형 변환되는 과정이 묵시적으로 이루어진다는 정도만 이해하면 됨.
	 * 
	 * [클래스의 상속 계층 구조가 여러간계일 경우에도 묵시적으로 형 변환이 되나?]
	 * 클래스의 상속 계층이  여러 단계일 경우도 사위 클래스로의 형 변환은 묵시적으로 이루어짐. 계층 구조에서 보면 포유류를 상속받은 호랑이와 영장류가 있고, 영장류를 상속받은 인간이 있음. 이때 인간은 Human형이면서 Primate형, Manmal형이 되므로 다음과 같이 코딩할 수 있음
	 * 
	 * Primate aHuman = new Human();
	 * Manmal mHuman = new Human();
	 * 
	 * 
	 * 					---- 호랑이(Tiger)
	 * 포유류(Manmal)----|
	 * 					---- 영장류(Primate) <-- 인간(Human)
	 * 
	 * 8-3 메서드 오버라이딩
	 * 
	 * 상위 클래스 메서드 재정의하기
	 * 8-1에서 새로운 등급을 만들면서 VIP 고객에게 제공하는 할인율과 세일 가격을 어떻게 적용할지 구현하지 않았음. 이제 그문제를 해결해보자.
	 * 
	 * 상위 클래스 Customer에는 제품 가격을 계산하는 calcPrice() 메서드가 이미 정의되어 있음. 이메서드는 정가를 그대로 지불함. 그런데 VIP 고객은 정가에서 10% 할인을 받을 수 있음. 이 경우에 상위 클래스의 calcPrice()메서드를 그대로 쓸 수 없음.
	 * 이렇게 상위 클레스에 정의한 메서드가 하위 클래스에서 구현할 내용과 맞지 않을 경우에 하위 클래스에서 이 메서드를 재정의할 수 있음. 이를 메서드 오버라이딩(method overriding)이라고 함. 오버라이딩을 하여면 반환형, 메서드 이름, 매개변수 개수,
	 * 매개변수 자료형이 반드시 같아야함. 그렇지 않으면 자바 컴파일러는 재정의한 메서드를 기존 메서드와 다른 메서드로 인식함.
	 * 
	 * -VIP 고객 클래스의 제품 가격 계산 메서드 재정의하기
	 * VIPCustomer 클래스에서 calcPrice() 메서드를 재정의해 보자.
	 * (VIPCustomer.java)
	 * 
	 * 하위 클래스 VIPCustomer에서 calcPrice() 메서드를 재정의 했음. 상위 클래스의 calcPrice()메서드와 매새변수의 자료형 및 개수가 같고, 반환형도 int형으로 같음.
	 *		return price - (int)(price * saleRatio);
	 * 위 코드는 할인율을 계산하여 정가에서 뺀 후 세일 가격을 반환함.
	 * 
	 * 상위 클래스의 메서드를 재정의할 때는 메서드 이름을 직접 써도 되고, 이클립스의 기능을 활용할 수도 있음. 코드에서 마우스 오른쪽 버튼을 누르고[Source -> Override/Implenment Methods..]을 누르면 메서드 선턱창이 나옴.
	 * 상위 클래스 Customer의 메-서드 중 재정의할 메서드를 선택할 수 있음. calcPrice(int)를 선택하고 [OK]를 누르면 재정의할 메서드의 코드가 VIPCustomer 클래스에 자동으로 생성됨
	 * 
	 * @Override
	 * public int  calcPrice(int price){
	 * 	//TODO Auto-generated method stub
	 * 	return super.calcPrice(price);
	 * }
	 * 
	 * @Override 애노테이션은 '이 메서드는 재정의된 메서드입니다'라고 컴파일러에 명확히 알려주는 역활을 함.
	 * 
	 * [애노테이션(Annotation)이란?]
	 * 애노테이션은 영어로는 주석이라는 의미. @ 기호와 함께 사용하며 '@애노케이션 이름'으로 표현함. 자바에서 제공하는 애노테이션은 컴파일어에게 특정한 정보를 제공해 주는 역활을 함.
	 * 예를 들어 @Override는 이 메서드가 재정의된 매서드임을 컴파일러에게 알려 줌. 만약 메서드의 선언부가 다르다면 컴파일 오류가 발생하여 프로그래머의 실수를 막아 줌. 이렇게 미리 정의되어 있는 애노테이션을
	 * 표준 애노테이션이라고 함. 주로 사용하는 표준 애노테이션은 다음과 같음.
	 * 	
	 * 		애노테이션						설명
	 * 	   @Override			재정의된 메서드라는 정보 제공
	 *  @Fuctionallnterface		함수형 인터페이스라는 정보 제공
	 *    @Deprecated			이후 버전에서 사용되지 않을 수 있는 변수, 메서드에 사용됨
	 *  @SuppressWarnings		특정 경고가 나타나지 않도록 함.
	 *  
	 * 이 외에도 애노테이션에 대해 좀 더 많은 정보를 추가할 수 있는 '메타 애노테이션'을 제공하고 있음.
	 * 
	 * 이순신 고객은 일반 등급이므로 정가 10,000원을 그대로 지불함. 하지만 김유신 고객은 VIP등급이므로 10% 할인을 받아 9,000원을 지불하도록 프로그램을 구현.
	 * 
	 * 	묵시적 클래스 형 변환과 메서드 재정의
	 * 
	 * Customer vc = new VIPCustomer("10030", "나몰라", 2000);
	 * vc.calcPrice(10000);
	 * 
	 * 묵시적 형 변환에 의해 vipCustomer가 Customer형으로 변환되었음. 그러고나서 calcPrice()메서드가 호출됨. calcPrice()는 하위 클래스에서 재정의된 메서드이며 Customer 클래스와 VIPCustomer 클래스에 모두 존재함.
	 * 그렇다면 vc.calcPrice(10000)은 어떤 클래스의 메서드를 호출할지 알아보자.
	 * (OverridingTest2.java)
	 * 
	 * 멤버 변수와 메서드는 선언한 클래스형에 따라 호출됨. 그러면 vc.calcPrice(10000)은 당연히 선언한 클래스인 Customer 클래스의 calcPrice()메서드를 호출함. 하지만 출력 결과를 보니 9,000원. VIPCustomer 클래스의
	 * calcPrice()메서드, 즉 재정의 된 메서드가 호출되었음을 알수 있음.
	 * 
	 * 상속에서 상위 클래스와 하위 클래스에 같은 이름의 메서드가 존재할 때 호출되는 메서드는 인스턴스에 따라 결정됨.
	 * 다시 말해 선언한 클래스형이 아닌 생성된 인스턴스의 메서드를 호출하는 검. 이렇게 인스턴스의 메서드가 호출되는 기술을 '가상 메서드'라고함. 가상 메서드가 실행되는 원리를 이애하면 왜 vc.calcPrice(10000)에 Customer 클래스의 메서드가 아닌
	 * 생성된 인스턴스, 즉 VIPCustomer의 메서드를 호출하는지 이해할 수 있음.
	 * 
	 * 	가상 메서드
	 * 자바의 클래스는 멤버 변수와 메서드로 이루어져 있음. 클래스를 생성하여 인스턴스가 만들어지면 멤버 변수는 힙 메모리에 위치함. 그렇다면 메서드는 어디에 위치할것인가? 변수가 사용하는 메모리와 메서드가 사용하는 메모리가 다름.
	 * 변수는 인스턴스가 생성될때마다 새로 생성되지만, 메서드는 실행해야 할 명령 집합이기 때문에 인스턴스가 달라도 같은 로직을 수행함. 즉 같은 객체의 인스턴스를 여러 개 생성한다고 해서 메서드도 여러개 생성되지 않음.
	 * (TestA.java)
	 * 
	 * TestA.java의 코드가 실행되는 메모리의 상태를 그림으로 나타내면 다음과 같음
	 * 	
	 * 		 힙 메모리			스택 메모리				메서드 영역
	 * 		a1의 num	  <--		a1	|	------>	  aaa() 메서드 영역
	 * 		a2의 num	  <--		a2	|	---|
	 * 						   args |
	 * 								|__>main()함수의 지역 변수
	 * 
	 * main() 함수가 실행되면 지역 변수는 스택 메모리에 위치함. 그리고 각 참조 변수 a1과 a2가 가리키는 인스턴스는 힙 메모리에 생성됨. 여기까지는 우리가 학습했던 내용임.
	 * 메서드의 명령 집합은 메서드 역역(코드 영역)에 위치함. 우리가 메서드를 호출하면 메서드 영역의 주소를 참조하여 명령이 실행됨. 따라서 인스턴스가 달라도 동일한 메서드가 호출됨.
	 * 
	 * -가상 메서드의 원리
	 * 일반적으로 프로그램에서 메서드를 호출한다는 것은 그 메서드의 명령 집압이 있는 메모리 위치를 참조하여 명령을 실행하는 것임. 그런데 가상 메서드의 경우에는 '가상 메서드 테이블'이 만들어짐. 가상 메서드 테이블은 각 메서드 이름과 실제 메모리 주소가 짝을 이루고 있음.
	 * 어떤 메서드가 호출되면 이 테이블에서 주소 값을 찾아서 해당 메서드의 명령을 수행함.
	 * 
	 * Customer 클래스의 가상 메서드 테이블
	 * 			메서드								   메서드 주소							 	메서드 영역
	 * 		calcPrice (재정의됨)		   				  OxFFOOFFAA	---> 1				| 1 Customer 클래스   |
	 * 		showCustomerInfo (재정의되지 않음)			  Ox112233AA	---> 2	 			|    calcPrice()    |
	 * 																					|___________________|	
	 * VIPCustomer 클래스의 가상 메서드 테이블                                     			| 2 Customer 클래스   |
	 * 			메서드																	| showCustomerInfo  |
	 * 		calcPrice (재정의됨)						  OxOO335577	---> 3				|___________________|
	 * 		showCustomerInfo (재정의되지 않음)			  Ox112233AA	---> 2				| 3 VIPCustomer클래스	|
	 * 		getAgentID								  Ox8899BB33	---> 4				| 재정의된 calcPrice()|
	 * 		(하위 클래스에서 추가된 메서드)														|___________________|
	 * 																					| 4 VIPCustomer클래스	|
	 * 																					| 	getAgent()		|
	 * 																					|___________________|
	 * 
	 * 그림에서 보득 calcPrice() 메서드는 두 클래스에서 서로 다른 메서드 주소를 가지고 있음. 이렇게 재정의 된 메서드는 시제 인스턴스에 해당하는 메서드가 호출됨.
	 * showCustomerInfo()와 같이 재정의되지 않은 메서드인 경우는 메서드 주소가 같으며 상위 클래스이 메서드가 호툴됨.
	 * 
	 * 예제를 통해 결과를 살펴보자. 가격이 10,000원인 상품이 있다. Customer 클래스로 인스턴스를 생성한 경우와 VIPCustomer 클래스로 인스턴스를 생성한 경우, 마지막으로 VIPCustomer 클래스로 인스턴스를 생성하여 Customer 클래스형으로 형 변환한 경우 각각
	 * 얼마를 지불해야하는지 알아보자.
	 * (OverridingTest3.java)
	 * 
	 * 7행에서 Customer형으로 선언하고 Customer 인스턴스를 생성하면 Customer의 메서드가 호출됨. 따라서 customerLee가 지불해야 할 가격은 할인이 안 된 10,000원임. 그리고 10행에서 VIPCustomer로 생성한 customerKim은 당연히 할인된 가격인 9,000월을
	 * 지불함. 마지막으로 13행에서 VIPCustomer로 생성하고 Customer형으로 변환한 vc는 원래 Customer형 메서드가 호출되는 것이 맞지만, 가상 메서드 방식에 의해 VIPCustomer 인스턴스의 메서드가 호출되어 할인 가격 9,000월이 출력됨.
	 * 
	 * 
	 * 					calcPrice() 재정의 안 된 경우 호출		Customer 클래스
	 * 					------------------------------>		 calcPrice()
	 * vc.calcPrice(); |		
	 * 				   |									VIPCustomer 클래스
	 * 					------------------------------>		 재정의된 calcPrice()
	 * 					calcPrice() 재정의된 경우 호출
	 * 
	 * 정리해보자. 상위 클래스(Customer)에서 선언한 calcPrice()메서드가 있고 이를 하위 클래스(VIPCustomer)에서 재정의한 상태에서 하위 클래스 인스턴스(vc)가 상위 클래스로 형변환이 되었음.
	 * 이떄 vc.calcPrice()가 호출되면, vc 변수를 선언할 때 사용한 자료형(Customer)의 메서드가 호출되는 것이 아니라 생성된 인스턴스(VIPCustomer)의 메서드가 호출됨. 이를 가상 메서드라고함. 자바의 모든 메서드는 가상메서드.
	 * 
	 * 
	 * 	08-4  다형성
	 * 
	 * 	다형성이란?
	 * 지금까지 설명한 묵시적 클래스 형 변환과 가상 메서드를 바탕으로 객체 지향의 중요한 특성인 다형성(polymorphism)을 학습하자.
	 * 다형성이란 하나의 코드가 여러 자료형으로 구현되어 실행되는 것을 말함. 쉽게 말해 같은 코드에서 여어 실행 결과가 나오는 것임.
	 * 
	 *						Amimal클래스
	 * 				 			|
	 * 			------------------------------------
	 * 			|				|					|
	 *		tiger 클래스		Human 클래스			Eagle 클래스
	 *
	 *

	 * 
	 * 위와 같이 3개의 크래스가 Animal 클래스를 상속받는 경우를 생각해보자. Animal 클래스에 메서드를 하나 정의하고 상속받은 클래스에서 재정의함. 이를 코드로 구현하면
	 * (polymorphism - AnimalTest.java)
	 * 
	 * 테스트를 위해 AnimalTest1 클래스에 moveAnimal() 메서드를 만들었음. 이 메서드는 어떤 인스턴스가 매개변수로 넘어와도 모두 Animal형으로 변환함.
	 * 매개변수가 전달되는 부분에 Human 인스턴스가 전달되었다면 다음 코드형 처럼 변환됨 [Animal ani = new Human();]
	 * Animal에서 상속받은 크래스가 매개변수로 넘어오면 모두 Animal형으로 변환되므로 animal.move() 메서드를 호출할 수 있음. 가상 메서드 원리에 따라 animal.move() 메서드가 호출하는 메서드는 animal의 move가 아닌 매개변수로 넘어온 실제 인스턴스의 메서드임.
	 * animal.move() 코드는 변함이 없지만 어떤 매개변수가 넘어왔느냐에 따라 출력문이 달라짐. 이적이 바로 다형성임.
	 * 
	 * 						Amimal클래스
	 * 						 move();
	 * 					 "동물이 움직임니다."
	 * 				 			|
	 * 			------------------------------------
	 * 			|				|					|
	 *		Human 클래스		tiger 클래스			Eagle 클래스
	 * 		 move();		  move();		  	 move();
	 * 	  사람이 두발로 겉음	  호랑이가 네발로 뜀		  독수리가 하늘을 남
	 * 
	 * 
	 * 	다형성의 장점
	 * 
	 * 다른 동물이 새로 추가되는 경우를 생각해보면, 새로운 동물도 Animal 클래스를 상속받아 구현하면 모든 클래스를 Animal 자료형 하나로 쉽게 관리할 수 있음. 이것이 다형성을 활용한 프로그램의 확장성임.
	 * 각 자료형에 따라 코드를 다르게 구현하다면 코드는 휠씬 복잡해지고 내용도 길어짐. 상위 클래스에서 공통 부분의 메서드를 제공하고, 하위 크래스에서는 그에 기반한 추가 요소를 덧붙여 구현하면 코드 양도 줄어들고 유지보수도 편리함.
	 * 또 필요에 따라 상속받은 모든 클래스를 하나의 상위 클래스로 처리할 수 있고 다형성에 의해 각 클래스의 여러 가지 구현을 실행할 수 있으므로 프로그램을 쉽게 확장할 수 있음.
	 * 이처럼 다형성을 잘 활용하면 유연하면서도 구조화된 코드를 구효ㅕㄴ하여 확장성 있고 유지보수하기 좋은 프로그램을 개발할 수 있음.
	 * 
	 * 
	 * -다형성을 활용해 VIP 고객 클래스 완성하기
	 * 앞에서 제시한 VIP 고객의 혜택을 다형성으로 구현해 보자.
	 * (Customer.java)
	 * 
	 * 기존 Customer 클래스와 달라진 점을 살펴보면 20~23형에 initCustomer() 메서드가 있음. 이 메서드는 클래스의 멤버 변수를 초기화하는데, Customer 클래스를 생성하는 두 생성자에서 공통으로 사용하는 코드이므로 메서드로 분리하여 호출.
	 * 이번에는 VIP 고객 클래스 코드를 수정해 보자.
	 * (VIPCustomer.java)
	 * 
	 * VIP 고객 클래스에서 calcPrice() 메서드와 showCustomerInfo() 메서드를 재정의했음. 이반 고객 크래스에서 calcPrice()메서드는 정가를 그대로 반환했지만, VIP 고객 클래스에서는 할인율을 반영한 지불 가격을 반환함.
	 * 또 일반 고객 클래스에서 showCustomerInfo() 메서드는 고객 등급과 이름만 출력했지만, VIP 고객 클래스에서는 담당 상담원 번호까지 출력함.
	 * (CustomerTest.java)
	 * 
	 * 출력 결과를 보면 10,000원짜리 상품을 구입했을때 등급에 따라 다른 할인율과 포인트 적립이 이루어지는 것을 알 수 있음. 그런데 여기에서 customerLee와 customerKim은 모두 Customer형으로 동일하지만 할인율과 보너스 포인트는 각 인스턴스의 메서드에 맞게 계산되었음.
	 * 즉 상속 관계에 있는 상위 클래스와 하위 클래스는 같은 상위 클래스 자료형으로 선언되어 생성할 수 있지만 재정의된 메서드는 각각 호출될 뿐만 아니라 이름이 같은 메서드가 서로 다른 역활을 구현하고 있음을 알 수 있음.
	 * 
	 * 
	 * 8-05 다형성 활용하기
	 * 
	 * 앞서 배운 상속과 다형성을 활용하면 프로그램을 유지보수하는데 매우 편리함. 이때 배열을 함께 사용하면 여러 하위 클래스 자료형을 사위 클래스 자료형으로 한꺼번에 관리할 수 있음.
	 * 
	 * -일반 고객과 VIP 고객의 중간 등급 만들기
	 * 
	 * (예제)고객이 늘어나 VIP 고객만큼 물건을 많이 구매하지는 않지만, 단골인 고객에세 혜택을 주고 싶어 GOLD 등급을 추가. GOLD 등급 혜택은 다음과 같음.
	 * # 제품 살 때 항상 10% 할인
	 * # 보너스 포인트 2% 적립
	 * # 담당 전문 상담원 없음
	 * 
	 * 새로운 고객 등급이 생김. 이등급의 고객은 VIP 고객과 보너스 포인트 적입률이 다르고 담당 상담원도 없음. 이 내용을 기반으로 Customer 클래스를 상속받아 GOLDCustomer 클래스를 만들어 보자.
	 * (GoldCustomer.java)
	 * 
	 * 					고객(Customer) 클래스
	 * 				아이디, 이름, 등급, 포인트, 포인트 적립율
	 * 							|
	 * 			-----------------------------
	 * 			|							|
	 * 		VIP 고객 클래스				GOLD 고객 클래스
	 * 	   담당 상담원 아이디					할인율
	 * 		  할인율
	 * 
	 * GoldCustomer 클래스는 지불 가격과 보너스 포인트를 계산하는 calcPrice() 메서드만 재정의 했음. 이처럼 상속을 사용하면 새로운 기능이 추가되더라도 쉽게 수현할 수 있음.
	 * 
	 * -배열로 고객 5명 구현하기
	 * 	예제:
	 * 	회사의 고객은 현재 5명. 5명 중 VIP 1명, GOLD 2명, SILVER 2명임. 이고객들이 각각 10,000원짜리 상품을 구매했을 때의 결과를 출력
	 * 
	 * 고객 인스턴스가 총 5개이므로 배열에 넣어서 관리하면 편리함. 객체 배열 ArrayList는 자료형을 지정하여 선언해야함. 우리가 사용할 클래스는 Customer, GoldCustomer, VIPCustomer 세종류임.
	 * 배열 자료형을 Customer로 지정하고, VIPCustomer 클래스와, GoldCustomer 클래스 모두 Customer에서 상속받은 클래스이므로 Customer형으로 선언함.
	 * 이렇게 선언하면 이 배열에는 Customer, GoldCustomer, VIPCustomer를 모두 사용할 수 있음. 그리고 이 배열에 Customer 하위 클래스의 인스턴스가 추가될 때 모두 Customer형으로 묵시적 형 변환이 됨.
	 * 
	 * 	ArrayList<Customer> customerLissst = new ArrayList<Customer>();
	 * 
	 * 테스트 프로그램을 구현해 보자.
	 * (Customer.java)
	 * 
	 * 6행에서 Customer형으로 객체 배열 ArrayList를 선언. 14행~18행까지 Customer 클래스와 하위 클래스 VIPCustomer, GoldCustomer의 인스턴스를 ArrayList에 추가했음.
	 * 21행에 향상된 for문에서 향상된 for문을 사용하여 고객 정보를 출력함. 고객 정보를 출력하는 showCustomerInfo() 메서드는 재정의하지 않았으므로 Customer 클래스에 구현된 메서드가 호출됨.
	 * 그리고 27행~31행에서 향상된 for문으로 각 고객이 지불해야 할 금액과 적립된 보너스 포인트를 출력함. 고객 등급에 따라 할인율과 적입금이 다르므로 calcPrice() 메서드는 각 클래스에 재정의 했음.
	 * for(Customer customer : customerList)문장은 customerList 배열의 요소를 하나씩 가져와서 Customer형 변수에 넣음. 고객 정보를 ArrayList 배열에 저장할 때 Customer형으로 형 변환을 하여 추가했기 때문에 배열 요소를 하나씩 가져올 때도
	 * Customer형으로 가져오게 됨. 고객 정보를 ArrayList 배열에 저장할 떄 Customer형으로 형 변환을 하여 추가했기 때문에 배열 요소를 하나씩 가녀올 때도 Customer형으로 가져오게 됨. 그리고 각 인스턴스가 calcPrice() 메서드를
	 * 호출하면 현재 이 변수의 실제 인스턴스가 무엇이냐에 따라 재정의한 매서드를 각각 호출하여 게산함. 이것이 다형성.
	 * 
	 * 만양 재정의한 메서드가 가상 메서드 방식에 의해 자동으로 호출되지 않는다면 if-else if문을 사용하여 각 자료형에 적합한 코드를 따로 구현해야 할 것임. 게다가 새로운 등급의 고객이 추가로 필요한 경우에는 또 다른 조건을 구현해야 하므로 코드의 유지보수가 어려워짐.
	 * 이런 경우에 상속과 다형성을 자 활용하면 복잡한 코드를 간결하게 줄일 우 있고 확장성 있는 프로그랴ㅐㅁ을 구현할 수 있음.
	 * 
	 * 상속은 언제 사용할까?
	 * VIP 고객 등급을 추가하는 문제를 다시 생각해보자. 이미 Customer 크래스가 구현되어있는데 추가 요구 사항이 생김. 사실 가장 간단하게 생각해 보면, 이미 Customer클래스가 존재하므로 여기에 추가내용을 함께 구현할 수도 있음. Customer 클래스에
	 * VIP고객의 내용도 함께 구현하는 것. 그런데 추가 기능을 이렇게 구현하면 코드가 굉장히 복잡해짐. 그 이유는 일반 등급 고객이 사용하지 않는 속성(상담원ID, 할인율 등)뿐만 아니라 VIP 고객만을 위한 서비스 내용까지 추가해야 하기 떄문.
	 * 아래 코드는 Customer 클래스에 모든 등급의 내용을 넣어 구현한 예임.
	 * 
	 * if(customerGrade == "VIP"){				//할인+적립금 최대
	 * } 
	 * 	else if(customerGrade == "GOLD"){		//할인+적입금 중간
	 * } 
	 * 	else if(customerGrade == "SILVER"){		//적립만
	 * }
	 * 
	 * 고객 등급에 따라 다르게 구현해야 하기 떄문에 if-else if-else문을 사용함. calcPrice() 메서드뿐 아니라 여러 다른 메서드에서도 등급에 따라 다른 구현이 필요하다며 클래스 전체에서 이러한 if-else if-else문이 많이 사용됨.
	 * 이런 경우 고객의 등급이 하나라도 추가되거나 ㅅ삭제되면 유지보수가 매우 복잡해짐.
	 * 
	 * 상속을 사용하면 모든 등급에서 공통으로 사용하는 코드 부분은 상위 클래스인 Customer 클래스에 구현하고, 각 등급별 고객의 내용은 각각의 하위 클래스에 구현함. 또한 새로운 등급의 고객ㄱ이 추가되더라도 기존의 코드를 거의 수정하지 않고 새로운 클래스를 추가할 수 있음.
	 * 따라서 프로그램이 확장성 있고 유지보수하기 좋음.
	 * 
	 * 
	 * 
	 */
}
