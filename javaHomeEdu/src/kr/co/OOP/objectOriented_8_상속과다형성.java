package kr.co.OOP;

public class objectOriented_8_상속과다형성 {

	/*
	 *	8-1	상속이란?
	 * 	
	 * 	객체 지향 프로그래밍의 중요한 특징 중 하나가 상속(inheritance)임. 상속은 우리가 일반적으로 알 듯 무엇인가를 물려받는다는 의미임.
	 * 	일례로 부묘가 자식에게 물려주는 재산을 상속이라함. 부모에게 재산을 상속받으면 상속받은 재산을 자신의 것으로 사용할 수 있음.
	 * 	객체 지향 프로그램에서도 마찬가지임. B 클래스가 A 클래스를 상속받으면 B 클래스는 A 클래스의 멤버 변수와 메서드를 사용할 수 있음.
	 * 	객체 지향 프로그램은 유지 보수하기 편하고 프로그램을 수정하거나 새로운 내욜을 추가하는 것이 유연한데, 그 기반이 되는 기술이 바로 상속임.
	 * 
	 * 	-클래스의 상속
	 * 
	 * 상속을 구체적으로 학습하기 전에 자바에서 상속과 관련하여사용하는 용어롸 문법에 대해 알아보자.
	 * B 클래스가 A 클래스에서 상속받는다고 할 때 다음과 같다.
	 * 
	 * 	(상위 클래스)	| A 클래스 |
	 *	 				^
	 *					|
	 * 					----------- A 클래스가 B 클래스에게 상속한다 = B 클래스가 A 클래스를 상속받는다.
	 * 					|
	 * 	(하위 클래스)	| B 클래스 |
	 * 
	 * 상속을 하는 클래스에서 상속을 받는 클래스로 화살표가 갈 것 같지만, 클래스 간 상 속을 표현할 때는 위 그림에서 표현한 것처럼 상속받는 클래스에서 상속하는 클래스로  화살표가 가므로 헷갈리면 안 됨.
	 * 부모 클래스를 '상위 클래스', 자식 클래스를 '하위 클래스'라고함.
	 * 
	 * 클래스 상속 문법
	 * 자바 문법으로 상속을 구현할 때는 extends 예약어를 사용함. 이때 사용하는 extends 예약어는 '연장, 확장하다'의 의미. 즈 A가 가지고 있는 속성이나 기능을 추가로 확장하여 B 클래스를 구현한다는 뜻.
	 * 그러면 일반적인 클래스 A에서 더 구체적인 클래스 B가 구현됨.
	 * class B extands A{
	 * }
	 * 위 코드는 'B 클래스가 A 클래스를 상속받는다'라고 함.
	 * 
	 * 	포유류(원숭이, 고래, 사자... 등) 	<--				 사람
	 * 	class Mammal{						class Human extends Mammal{
	 * 		...						<--			...
	 * 	}									 }
	 * 
	 * 포유류는 사람보다 일반적인 개념임. 즉 사람은 포유류의 특징과 기능을 기본으로 더 많거나 다른 특징과 기능을 가지고 있음. 이렇게 상속 관계에서는 상위 클래스가 하위 클래스보다 일반적인 개념이고, 하위 클래스는 상위 클래스보다
	 * 구체적인 클래스가 됨. 
	 * 
	 * 	-상속을 사용하여 고객 관리 프로그램 구현하기
	 * 
	 * 회사에서 고객 정보를 가지고 맞춤 서비스를 제공하기 위해 고게ㅐㄱ 관리 프로그램으로 구현하려고 함. 그러면 먼저 고객 클래스가 있어야함 고객 클래스를 구현하려면 클래스 속성을 멤버 변수로 선언하면 됨.
	 * 이 예제에서는 고객 아이디, 이름, 고객 등급, 보너스 포인트, 보너스 포인트 적립 비율을 속성으로 선언.
	 * (inheritance - Customer.java)
	 * 
	 * 예제에서 사용한 멤버 변수를 살펴보면 다음과 같음
	 * 
	 * 	customerID		고객 아이디
	 *	customerName	고객 이름
	 *	customerGrade	고객 등급 - 기본생성자에서 지정되는 기본 등급은 SILVER임.
	 *	bonusPoint		고객의 보너스 포인트 - 고객이 제품을 구매할 경우 누적되는 보너스 포인트임.
	 *	bonusRatio		보너스 포인트 적립 비율 - 고객이 제품을 구매할 때 구매 금액의 일정 비율이 보너스포인트로 적립됨. 이때 계산되는 적립 비율임.
	 * 		   							  - 기본 생성자에서 지정되는 적입 비율은 1%dla wmr 10,000월짜리를 사면 100원이 적립됨.
	 * 
	 * 모든 멤버 변수를 반드시 private으로 선언할 필요 없음. 필요에 따라 멤버 변수나 메서드를 외부에 노출하지 않을 목적일 때 private으로 선언함. 예제에서 사용한 메서드.
	 * 
	 * Customer()			기본 생성자임. 고객 한명이 새로 생성되면 customerGrade는 SILVER이고, bonusPoint는 1%로 지정됨.
	 * calcPrice()			제품에 대해 지불해야 하는 금액을 계산하여 반환됨. 할인되지 않는 경우 가격을 그대로 반환함. 그리고 가격에 대해 보너스 포인트 비율을 적용하여 보너스 포인트를 적립함.
	 * showCustomerInfo()	고객 정보를 출력함. 고객 이름과 등급, 현재 적입된 포인트를 보여줌.
	 * 
	 * 새로운 고객 등급이 필요한 경우
	 * ------------------------------------------------------------------------------------------------------------------------------
	 * 예제 시나리오
	 * 고객이 점점 늘어나고 판매도 많아지다보니 단곡 고객이 생김. 단골 고객은 회사 매출에 많은 기여를 하는 우수 고객임. 이 우수 고객에서 좋은 혜택을 주고 싶음.
	 * 우수 고객 등급은 VIP이고, 다음과 같은 혜택을 제공함.
	 * 	-제품을 살 때는 항상 10% 할인해 줌.
	 * 	-보너스 포인트를 5% 적입해 줌.
	 * 	-담당 전문 상담원을 배정해 줌.
	 * ------------------------------------------------------------------------------------------------------------------------------
	 * 
	 * 위 같은 요구 사항을 구현하는 방법은 무엇일까. 이미 Customer 클래스가 존재하므로 Customer 클래스에 VIP 고객에 필요한 변수와 메서드까지 함께 포함하여 구현. 하지만 이렇게 구현하게되면 Customer 클래스의 코드가 복잡해짐.
	 * 게다가 일반 고객의 인스턴스를 생성할 때는 VIP 고객과 관련된 기능은 전혀 필요 없는데 VIP 고객의 내용까지 같이 생성되어 낭비가 발생. 이러한 경우는 VIPCustomer 크래스를 따로 만드는것이 좀음.
	 * (inheritance - VIPCustomer.java)
	 * 
	 * 클래스를 만들고 보니 앞에서 만든 Customer 클래스와 겹치는 멤버 변수와 메서드가 보임. CalcPrice() 메서드는 이름은 같지만 구현 내용은 다름. VIP 고객도 고객임. 다만 일반 고객에게 제공하는 혜택을 기본으로 제공하고
	 * 추가 속성과 메서드가 있는검. 이건 경우사 상속을 사용함.
	 * 즉 CUstomer 클래스에 일반 고객의 속성과 기능이 이미 구현되어 있기 떄문에 VIPCustomer 클래스는 Customer 클래스를 상속받고 VIP 고객에게 필요한 추가 속성과 기능을 구현하는것임. Customer 클래스를 상속한 VIPCustomer 클래스의 코드는 다음과 같다.
	 * (VIPCustomer.java -> 기존 변수 입력방식(주석 처리)이 아닌 상속방식으로 수정)
	 * 
	 * VIPCustomer 클래스의 코드가 간단해졌음. Customer 클래스에 이미 선언되어 있는 cusromerID, customerName, customerGrade, bonusPoint, bonusRatio 멤버 변수와 calcPrice(), showCustomerInfo() 메서드는 상속을 받아서 사용할 것이기 때문에 구현하지 않음.
	 * 해당 코드에서는 두 가지 문제가 있음. 첫째, customerGrade 변수에서 오류가 발생. 상위 클래스에 선언한 변수인데 오류가 발생한 이류는 private 변수이기 때문. 해당 변수는 외부클래스에서 사용할 수 없음.
	 * 두번째는 VIP 고객에서 제공하는 혜택인 할인율 과 세일 가격을 어떻게 적용할지 구현하지 않았다는 점임.-> 이부분은 8-3 메서드 오버라이딩에서.
	 * 
	 * 상위 클래스 변수를 사용하기 위한 protected 예약어
	 * customerGrade 변수에서 발생하는 오류부터 수정해보자. 이 오류는 상위 클래스에 선언한 customerGrade가 private 변수이기 때문에 발생. 상위 클래스에 작성한 변수나 메서드 중 외부 클래스에서 사용할 수 없지만 하위 클래스에서는 사용할 수 있도록 지정하는 예약어가
	 * 바로 protected임. 상위받은 하위 클래스에서는 public처럼 사용할 수 있는 검임. 즉 protected는 상속된 하위 클래스를 제외한 나머지 외부 클래스에서는 private와 동일한 역할을 함.
	 * 
	 * Customer 클래스에 있는 private 변수를 다른 하위 크래스에서도 사용할 수 있도록 protected로 바꿔보겠음. 그리고 protected로 선언한 customerID, customerName, customerGrade 변수를 사용하기 위해 get(), set() 메서드를 추가해보자.
	 * (Customer.java - private 변수를 protected로 변경, get(),set() 생성)
	 * 
	 * protected 예약어로 선언한 변수는 외부 클래스에는 private 변수처럼 get() 메서드를 사용해 값을 가져올 수 있고, set() 메서드를 사용해 값을 지정할 수 있음. customer 클레스를 상속받은 VIPCustomer 클래스는 protected로 선언한 변수를 상속받게 되고,
	 * 나머지 public 메서드도 상속받아 사용할 수 있음. 위와 같이 protected로 선언하면 VIPCustomer 부분의 오류는 사라짐.
	 * 
	 * 테스트 프로그램 실행하기
	 * 간단한 테스트 프로그램을 만들어 두 클래스를 생성해 보자
	 * ----------------------------------------------------------------------------------------------------------
	 * 예제 시나리오
	 * 일반 고객 1명, VIP 고객 1명이 있음. 일반 고객의 이름은 이순신, ID는 10010, 현재 보유 보너스 포인트 1000점.
	 * VIP 고객의 이름은 김유신, ID는 10020, 현재 보유 보너스 포인트는 10000점
	 * ----------------------------------------------------------------------------------------------------------
	 * 
	 * 새로운 Customer 클래스를 생성하고 customerLee 참조 변수에 대입.
	 * VIPCustomer 클래스를 생성하고 customerKim 참조 변수에 대입.
	 * VIPCustomer가 Customer를 상속 했기 떄문에 고객 아이디, 고객 이름의 메서드를 사용할 수 있음. 두 고객의 속인인 아이디, 이름,보너스 포인트를 지정하고 showCustomerInfo() 메서드를 사용해 고객 정보를 출력함.
	 * 
	 * 8-2 상속에서 클래스 생성과 형 변환
	 * 
	 * 하위 클래스가 생성될 때 상위 클래스의 생성자가 먼저 호출됨. 상속 관계에서 클래스의 생성 과정을 사펴보면 하위 클래스가 상위 클래스의 변수와 메서드를 사용할 수 있는 이유와 하위 클래스가 상위 클래스의 자료형으로 형 변환을 할 수 있는 이유를 이해할 수 있음.
	 * 
	 * -하위 클래스가 생성되는 과정
	 * 상속을 받는 아휘 클래스는 상위 클래스의 변수와 메서드를 사용할 수 있음. 즉 CustomerTest 예제를 살펴보면, VIPCustomer 클래스로 선언한 customerKim 인스턴스는 상속받은 상위 클래스의 변수를 자기 것처럼 사용할 수 있음.
	 * 변수를 사용할 수 있다는 것은 그 변수를 저장하고 있는 메모리가 존재한다는 뜻. VIPCustomer 클래스의코드를 보면 해당 변수가 존재하지 않음. Customer 클래스를 상속받았을 뿐. 상속된 아휘 클래스가 생성되는 과정을 다시 생각해 볼 필요가 있음.
	 * 테스트를 하기 위해 Customer와 VIPCustomer 클래스 생성자에 출력문을 추가.
	 * (Customer.java, VIPCustomer.java -> 각각 출력문 추가)
	 * 
	 * CustomerTest2 출력값을 보면 상위 클래스의 Customer() 생성자가 먼저 호출되고 그다음에 VIPCustomer()가 호출되는 것을 할 수 있음. 정리하면 상위 클래스를 상속받은 하위 클래스가 생성될 때는 반드시 상위클래스가 먼저 호출됨. 상위 클래스 생성자가 호출될 때 상위 클래스의 멤버 변수가 메모리에 생성되는것임.
	 * 하위 클래스 VIPCustomer가 생성될 때 메모리 구조를 간다히 그려보면 다음과 같음.
	 * 
	 * 	  힙 메모리
	 * 	customerID		-
	 *  customerName	|
	 *  customerGarade	|--> Customer() 생성자 호출 -> Customer클래스의 멤버 변수가 메모리에 생성됨
	 *  bonusPoint		|
	 *  bonusRatio	    -
	 *  agentID			-
	 *  salesRatio		---> VIPCustomer() 생성자 호출 -> VIPCustomer 클래스의 멤버 변수가 메모리에 생성됨
	 *  
	 *  상위 클래스의 변수가 메모리에 먼저 생성되기 떄문에 하위 클래스에서도 이 값들을 모두 사용할 수 있음. 08-1에서 상위 클래스의 변수를 private으로 선언한 경우에 하위 클래스에서 해당 변수를 사용할 수 없었던 건은 단지 하위 클래스에서 접근할 수 없었을 분임.
	 *  지금까지는 하위 클래스가 생성될 떄 상위 클래스가 먼저 만들어진다는 것을 배웠음. 이제 어떤과정으로 상위 클래스가 생성되는지 알아보자.
	 *
	 * -부모를 부르는 예약어 super
	 * super 예약어는 하위 클래스에서 상위 클래스로 접근할 떄 사용함. 하위 클래스는 상위 클래스이 주소,(참조 값)을 알소 있음. 이 참조값을 가지고 있는 예약어가 바로 super
	 * this가 가기 자신의 참조 값을 가지고 있는 것과 같다고생각하면 됨. super는 상위 클래스의 생성자를 호출하는 데도 사용.
	 * 
	 * 상위 클래스 생성자 호출하기
	 * CustomerTest2.java 예제를 보면 VIPCustomer만 생성하였는데 Customer 상위 크래스도 생성된것을 할 수 있음. 하위 클래스 생성자만 호출했는데 상위 클래스 생성자가 호출되는 이유는 하위 클래스 생성자에서 super()를 자동 호출하기 때문임.
	 * super()를 호출하면 상위 클래스의 디폴트 생성자가 호출됨. 하위 클래스의 디폴트 생서자는 바이트 코드로 변환되기 전에 다음과 같이 코드가 자동으로 변경됨.
	 * (CustomerTest2.java)
	 * 
	 * super 예약어로 매개변수가 있는 생성자 호쿨하기
	 * 이런 경우를 생각해보자. Customer 클래스를 생성할 때 고객 ID와 이름을 반드시 지정해야 한다고 가정, 이런 경우에 set() 메서드로 값을 지정하는 것이 아니고, 새로운 생성자를 만들어서 매겨변수로 값을 전달받아야함.
	 * 즉 디폴트 생성자가 아닌 매개변수가 있는 생성자를 직접 구현해야함. Customer 클래스에 새로운 생성자를 추가하고, 기존의 디폴트 생성자는 삭제하거나 주석 처리해보자.
	 * (Customer.java)
	 * 
	 * Customer 클래스의  디퐁트 생성자를 없애고 새로운 생성자를 작성하면, Customer 클래스를 상속받은 VIPCustomer 클래스에서 오류가 발생함. 오류가 발생한 디폴트 생성자에 마우스를 오려 보면 다음과 같은 오류 메시지가 보임.
	 * Implicit super constructor  Customer() is undefined, Must explicitly invoke another constructor
	 * 이 오류 메시지는 묵시적으로 호출될 디폴트 생성자 Customer()가 정의되지 않았기 떄문에, 반드시 명싲적으로 다른 생성자를 호출해야 한다는뜻.
	 * 
	 * Customer 클래스를 새로 생성할 떄 고객 ID와 고객 이름을 반드시 지정하여 생성하기로했으니 VIPCustomer 클래스를 생성할 때도 이 값이 필요함. 그리고 VIP 고객만을 위한 상담원 ID까지 함께 지정해보자.
	 * 기존 VIPCustomer 클래스의 디폴트 생성자도 지우거나 주석 처리한 후 필요한 매개변수를 포함하는 새성자를 새로 작성해보자
	 * (VIPCustomer.java)
	 * 
	 * 새로운 생성자는 고객 ID, 고객 이름, 상담원 ID를 매개변수로 받음. super 예약어는 상위 클래스 생성자를 호출하는 역할을 하며, 3행 super(customerID, customerName); 문장으로 상위 클래스 생성자를 호출함.
	 * VIPCustomer(int customerID, String customerName, int agentID) 생성자의 코드가 실제로 실행되는 형태는 다음과 같음.
	 
	 * public VIPCustomer(int customerID, String customerName, int agentID) {
	 *	super(customerID, customerName);
	 *	customerGrade = "VIP";
	 *	bonusRatio = 0.05;
	 *	saleRatio = 0.1;
	 *	System.out.println("VIPCustomer() 생성자 호출");
	 *}
	 * 
	 * super()를 통해 Customer(int customerID, String customerName) 상위 클래스 생성자를 호출하고 코드 순서대로 멤버 변수가 초기화됨. 상위 클래스 생성자 호출이 끝나면 VIPCustomer 하위 클래스 생성자의 내부 코드 수행이 마무리됨.
	 * 
	 * ^ 하위 클래스가 생성될 때는 상위 클래스의 [생성자]가 먼저 호출됨.
	 * ^ 상위 클래스에 생성자 코드가 따로 없으면 [super()]로 상위 클래스의 디폴트 생성자가 자동으로 호출됨.
	 * ^ 상위 클래스에 디폴트 생성자가 없고 매개변수가 있는 생성자만 있을 경우 [super()]에 매개변수를 추가하여, 매개변수가 있는 상위 클래스의 생성자를 직접 호출해야함.
	 * 
	 * 상위 클래스의 멤버 변수나 메서드를 참조하는 super
	 * 상위 클래스에 선언한 멤버 변수나 메서드를 하위 클래스에서 참조할 때도 super를 사용함. this를 사용하여 자신의 멤버에 접근했던 것과 비슷. 예를 들어 VIPCustomer 클래스의 showVIPInfo() 메서드에서 상위 클래스의 showCustomerInfo() 메서드를 참조해
	 * 담당 상담원 아이디를 추가호 출력하려고 할 떄 다음과 같이 구현할 수 있음.
	 * 
	 * public String showVIPInfo(){
	 * 	return super.showCustomerInfo() + "담당 상담원 아이디는" + agentID + "입니다";
	 * }
	 * 
	 * super 예약어는 상위 클래스의 참조 값을 가지고 있으므로 위 코드처럼 사용하면 고객 정보를 출력하는 showCustomerInfo() 메서드를 새로 구현하지 않고 상위 클래스의 구현 내용을 활용할 수 있음.
	 * 물론 위 코드의 VIPInfo() 메서드에서는 굳이 super.showCustomerInfo()라고 호출하지 않아도 상위 클래스의 메서드가 잘 호출됨.
	 * 아직 배우지 않았지만 하위 클래스가 상위 클래스와 동일한 이름의 메서드를 수형하는 경우도 있음. 이러한 경우 하위 클래스에서 동일한 이르므이 상위 클래스 메서드를 사리킬 때 super.showCustomerInfo()라고 써야함.
	 * 
	 *  -상위 클래스로 묵시적 클래스 형 변환
	 *  
	 * 상속을 공부하면서 우리가 이해해야 하는 중요한 관계가 클래스 간의 형 변환임. 일단 Customer와 VIPCustomer의 관계를 생각해 보자. 개념 면에서 보면 상위 클래스인 Customer가 VIPCustomer보다 일반적인 개념이고,
	 * 기능 면에서 보면 VIPCustomer가 Customer보다 기능이 더 많음. 왜냐하면 상속받은 클래스는 상위 클래스 기능을 모두 사용할 수 있고 추가로 더 많은 기능을 구현하기 떄문.
	 *  
	 * 따라서 VIPCustomer는 VIPCustomer형이면서 동시에 Customer형이기도 함. 즉 VIPCustomer 클래스로 인스턴스를 생성할 때 이 인스턴스의 자료형을 Customer형으로 클래스 형 변환하여 선언할 수 있음.
	 * 왜냐하면 VIPCustomer 클래스는 Customer 클래스를 상속받았기 떄문임.
	 * 
	 * 선언된 클래스형							생성된 인스턴스의 클래스형
	 * (상위 클래스형)							  (하위 클래스형)
	 * 	Customer 		vc 		=		 new VIPCustomer();
	 * 
	 * 그러면 반대로 Customer로 인스턴스를 생성할 떄 VIPCustomer형으로 선언할 수 없음. 상위 클래스인 Customer가 VIPCustomer클래스의 기능을 다 가지고 있지 않음.
	 * 정리하자면, 모든 하위 클래스는 상위 클래스 가료형으로 형변환될 수 있지만, 그 역은 성립하지 않음. 따라서 아휘 클래스인 VIPCustomer는 상위 클래스 Customer형을 내포하고 있기 때문에 Customer형으로 형 변환할 수 있음.
	 * 하지만 그 역은 성립될수 없음.
	 * 
	 *  형 변환된 vc가 가르키는 것
	 * Customer vc = new VIPCustomer();에서 형 변환된 vc가 가리키는 것은 무엇일까? 메모리 그림을 샃펴보자
	 *
	 * 		힙 메모리
	 * 	  customerID	--
	 *    customerName	 |
	 *    customerGrade	 |-- 1) Customer() 생성자 호출
	 *    bonusPoint	 |	  -> Customer 클래스의 멤버 변수가 메모리에 생성됨
	 *    bounsRatio	--
	 *  ------------------- 
	 *    agentID		---- 2) VIPCustomer() 생성자 호출
	 *    salesRatio	_|	  -> VIPCustomer 클래스의 멤버 변수가 메모리에 생성됨
	 * 
	 * Customer vc = new VIPCustomer(); 문장이 싱행되면 VIPCustomer 생성자가 허출되므로 클래스 변수가 위와 같이 메모리에 만들어짐.
	 * 그런데 클래스의 자료형이 Customer로 한정됨. 클래스가 형 변환이 되었을 때는 선언한 클래스형에 기반하여 멤버 변수와 메서드에 접근할 수 있음. 따라서 이 vc 참조 변수가 가리킬 수 있는 변수와 메서드는 Customer 클래스의 멤버뿐임.
	 * 이클랩스에서 vc변수에서 ctrl+spacebar를 눌러 보면 vc 참조 변수가 접근할 수 있는 변수와 메서드가 나타남.
	 * 
	 * 클래스 형 변환을 사용하는 이유는 '8-03 메서드 오버라이팅'과 '8-03 다형성'에서 자세히 다룸.
	 * 여기서는 일단 하위 클래스의 인스턴스가 상위 클래스로 형 변환되는 과정이 묵시적으로 이루어진다는 정도만 이해하면 됨.
	 * 
	 * [클래스의 상속 계층 구조가 여러간계일 경우에도 묵시적으로 형 변환이 되나?]
	 * 클래스의 상속 계층이  여러 단계일 경우도 사위 클래스로의 형 변환은 묵시적으로 이루어짐. 계층 구조에서 보면 포유류를 상속받은 호랑이와 영장류가 있고, 영장류를 상속받은 인간이 있음. 이때 인간은 Human형이면서 Primate형, Manmal형이 되므로 다음과 같이 코딩할 수 있음
	 * 
	 * Primate aHuman = new Human();
	 * Manmal mHuman = new Human();
	 * 
	 * 
	 * 					---- 호랑이(Tiger)
	 * 포유류(Manmal)----|
	 * 					---- 영장류(Primate) <-- 인간(Human)
	 * 
	 * 8-3 메서드 오버라이딩
	 * 
	 * 상위 클래스 메서드 재정의하기
	 * 8-1에서 새로운 등급을 만들면서 VIP 고객에게 제공하는 할인율과 세일 가격을 어떻게 적용할지 구현하지 않았음. 이제 그문제를 해결해보자.
	 * 
	 * 상위 클래스 Customer에는 제품 가격을 계산하는 calcPrice() 메서드가 이미 정의되어 있음. 이메서드는 정가를 그대로 지불함. 그런데 VIP 고객은 정가에서 10% 할인을 받을 수 있음. 이 경우에 상위 클래스의 calcPrice()메서드를 그대로 쓸 수 없음.
	 * 이렇게 상위 클레스에 정의한 메서드가 하위 클래스에서 구현할 내용과 맞지 않을 경우에 하위 클래스에서 이 메서드를 재정의할 수 있음. 이를 메서드 오버라이딩(method overriding)이라고 함. 오버라이딩을 하여면 반환형, 메서드 이름, 매개변수 개수,
	 * 매개변수 자료형이 반드시 같아야함. 그렇지 않으면 자바 컴파일러는 재정의한 메서드를 기존 메서드와 다른 메서드로 인식함.
	 * 
	 * -VIP 고객 클래스의 제품 가격 계산 메서드 재정의하기
	 * VIPCustomer 클래스에서 calcPrice() 메서드를 재정의해 보자.
	 * (VIPCustomer.java)
	 * 
	 * 하위 클래스 VIPCustomer에서 calcPrice() 메서드를 재정의 했음. 상위 클래스의 calcPrice()메서드와 매새변수의 자료형 및 개수가 같고, 반환형도 int형으로 같음.
	 *		return price - (int)(price * saleRatio);
	 * 위 코드는 할인율을 계산하여 정가에서 뺀 후 세일 가격을 반환함.
	 * 
	 * 상위 클래스의 메서드를 재정의할 때는 메서드 이름을 직접 써도 되고, 이클립스의 기능을 활용할 수도 있음. 코드에서 마우스 오른쪽 버튼을 누르고[Source -> Override/Implenment Methods..]을 누르면 메서드 선턱창이 나옴.
	 * 상위 클래스 Customer의 메-서드 중 재정의할 메서드를 선택할 수 있음. calcPrice(int)를 선택하고 [OK]를 누르면 재정의할 메서드의 코드가 VIPCustomer 클래스에 자동으로 생성됨
	 * 
	 * @Override
	 * public int  calcPrice(int price){
	 * 	//TODO Auto-generated method stub
	 * 	return super.calcPrice(price);
	 * }
	 * 
	 * @Override 애노테이션은 '이 메서드는 재정의된 메서드입니다'라고 컴파일러에 명확히 알려주는 역활을 함.
	 * 
	 * [애노테이션(Annotation)이란?]
	 * 애노테이션은 영어로는 주석이라는 의미. @ 기호와 함께 사용하며 '@애노케이션 이름'으로 표현함. 자바에서 제공하는 애노테이션은 컴파일어에게 특정한 정보를 제공해 주는 역활을 함.
	 * 예를 들어 @Override는 이 메서드가 재정의된 매서드임을 컴파일러에게 알려 줌. 만약 메서드의 선언부가 다르다면 컴파일 오류가 발생하여 프로그래머의 실수를 막아 줌. 이렇게 미리 정의되어 있는 애노테이션을
	 * 표준 애노테이션이라고 함. 주로 사용하는 표준 애노테이션은 다음과 같음.
	 * 	
	 * 		애노테이션						설명
	 * 	   @Override			재정의된 메서드라는 정보 제공
	 *  @Fuctionallnterface		함수형 인터페이스라는 정보 제공
	 *    @Deprecated			이후 버전에서 사용되지 않을 수 있는 변수, 메서드에 사용됨
	 *  @SuppressWarnings		특정 경고가 나타나지 않도록 함.
	 *  
	 * 이 외에도 애노테이션에 대해 좀 더 많은 정보를 추가할 수 있는 '메타 애노테이션'을 제공하고 있음.
	 * 
	 * 이순신 고객은 일반 등급이므로 정가 10,000원을 그대로 지불함. 하지만 김유신 고객은 VIP등급이므로 10% 할인을 받아 9,000원을 지불하도록 프로그램을 구현.
	 * 
	 * 	묵시적 클래스 형 변환과 메서드 재정의
	 * 
	 * Customer vc = new VIPCustomer("10030", "나몰라", 2000);
	 * vc.calcPrice(10000);
	 * 
	 * 묵시적 형 변환에 의해 vipCustomer가 Customer형으로 변환되었음. 그러고나서 calcPrice()메서드가 호출됨. calcPrice()는 하위 클래스에서 재정의된 메서드이며 Customer 클래스와 VIPCustomer 클래스에 모두 존재함.
	 * 그렇다면 vc.calcPrice(10000)은 어떤 클래스의 메서드를 호출할지 알아보자.
	 * (OverridingTest2.java)
	 * 
	 * 멤버 변수와 메서드는 선언한 클래스형에 따라 호출됨. 그러면 vc.calcPrice(10000)은 당연히 선언한 클래스인 Customer 클래스의 calcPrice()메서드를 호출함. 하지만 출력 결과를 보니 9,000원. VIPCustomer 클래스의
	 * calcPrice()메서드, 즉 재정의 된 메서드가 호출되었음을 알수 있음.
	 * 
	 * 상속에서 상위 클래스와 하위 클래스에 같은 이름의 메서드가 존재할 때 호출되는 메서드는 인스턴스에 따라 결정됨.
	 * 다시 말해 선언한 클래스형이 아닌 생성된 인스턴스의 메서드를 호출하는 검. 이렇게 인스턴스의 메서드가 호출되는 기술을 '가상 메서드'라고함. 가상 메서드가 실행되는 원리를 이애하면 왜 vc.calcPrice(10000)에 Customer 클래스의 메서드가 아닌
	 * 생성된 인스턴스, 즉 VIPCustomer의 메서드를 호출하는지 이해할 수 있음.
	 * 
	 * 	가상 메서드
	 * 자바의 클래스는 멤버 변수와 메서드로 이루어져 있음. 클래스를 생성하여 인스턴스가 만들어지면 멤버 변수는 힙 메모리에 위치함. 그렇다면 메서드는 어디에 위치할것인가? 변수가 사용하는 메모리와 메서드가 사용하는 메모리가 다름.
	 * 변수는 인스턴스가 생성될때마다 새로 생성되지만, 메서드는 실행해야 할 명령 집합이기 때문에 인스턴스가 달라도 같은 로직을 수행함. 즉 같은 객체의 인스턴스를 여러 개 생성한다고 해서 메서드도 여러개 생성되지 않음.
	 * (TestA.java)
	 * 
	 * TestA.java의 코드가 실행되는 메모리의 상태를 그림으로 나타내면 다음과 같음
	 * 	
	 * 		 힙 메모리			스택 메모리				메서드 영역
	 * 		a1의 num	  <--		a1	|	------>	  aaa() 메서드 영역
	 * 		a2의 num	  <--		a2	|	---|
	 * 						   args |
	 * 								|__>main()함수의 지역 변수
	 * 
	 * main() 함수가 실행되면 지역 변수는 스택 메모리에 위치함. 그리고 각 참조 변수 a1과 a2가 가리키는 인스턴스는 힙 메모리에 생성됨. 여기까지는 우리가 학습했던 내용임.
	 * 메서드의 명령 집합은 메서드 역역(코드 영역)에 위치함. 우리가 메서드를 호출하면 메서드 영역의 주소를 참조하여 명령이 실행됨. 따라서 인스턴스가 달라도 동일한 메서드가 호출됨.
	 * 
	 * -가상 메서드의 원리
	 * 일반적으로 프로그램에서 메서드를 호출한다는 것은 그 메서드의 명령 집압이 있는 메모리 위치를 참조하여 명령을 실행하는 것임. 그런데 가상 메서드의 경우에는 '가상 메서드 테이블'이 만들어짐. 가상 메서드 테이블은 각 메서드 이름과 실제 메모리 주소가 짝을 이루고 있음.
	 * 어떤 메서드가 호출되면 이 테이블에서 주소 값을 찾아서 해당 메서드의 명령을 수행함.
	 * 
	 * Customer 클래스의 가상 메서드 테이블
	 * 			메서드								   메서드 주소							 	메서드 영역
	 * 		calcPrice (재정의됨)		   				  OxFFOOFFAA	---> 1				| 1 Customer 클래스   |
	 * 		showCustomerInfo (재정의되지 않음)			  Ox112233AA	---> 2	 			|    calcPrice()    |
	 * 																					|___________________|	
	 * VIPCustomer 클래스의 가상 메서드 테이블                                     			| 2 Customer 클래스   |
	 * 			메서드																	| showCustomerInfo  |
	 * 		calcPrice (재정의됨)						  OxOO335577	---> 3				|___________________|
	 * 		showCustomerInfo (재정의되지 않음)			  Ox112233AA	---> 2				| 3 VIPCustomer클래스	|
	 * 		getAgentID								  Ox8899BB33	---> 4				| 재정의된 calcPrice()|
	 * 		(하위 클래스에서 추가된 메서드)														|___________________|
	 * 																					| 4 VIPCustomer클래스	|
	 * 																					| 	getAgent()		|
	 * 																					|___________________|
	 * 
	 * 그림에서 보득 calcPrice() 메서드는 두 클래스에서 서로 다른 메서드 주소를 가지고 있음. 이렇게 재정의 된 메서드는 시제 인스턴스에 해당하는 메서드가 호출됨.
	 * showCustomerInfo()와 같이 재정의되지 않은 메서드인 경우는 메서드 주소가 같으며 상위 클래스이 메서드가 호툴됨.
	 * 
	 * 예제를 통해 결과를 살펴보자. 가격이 10,000원인 상품이 있다. Customer 클래스로 인스턴스를 생성한 경우와 VIPCustomer 클래스로 인스턴스를 생성한 경우, 마지막으로 VIPCustomer 클래스로 인스턴스를 생성하여 Customer 클래스형으로 형 변환한 경우 각각
	 * 얼마를 지불해야하는지 알아보자.
	 * (OverridingTest3.java)
	 * 
	 * 7행에서 Customer형으로 선언하고 Customer 인스턴스를 생성하면 Customer의 메서드가 호출됨. 따라서 customerLee가 지불해야 할 가격은 할인이 안 된 10,000원임. 그리고 10행에서 VIPCustomer로 생성한 customerKim은 당연히 할인된 가격인 9,000월을
	 * 지불함. 마지막으로 13행에서 VIPCustomer로 생성하고 Customer형으로 변환한 vc는 원래 Customer형 메서드가 호출되는 것이 맞지만, 가상 메서드 방식에 의해 VIPCustomer 인스턴스의 메서드가 호출되어 할인 가격 9,000월이 출력됨.
	 * 
	 * 
	 * 					calcPrice() 재정의 안 된 경우 호출		Customer 클래스
	 * 					------------------------------>		 calcPrice()
	 * vc.calcPrice(); |		
	 * 				   |									VIPCustomer 클래스
	 * 					------------------------------>		 재정의된 calcPrice()
	 * 					calcPrice() 재정의된 경우 호출
	 * 
	 * 정리해보자. 상위 클래스(Customer)에서 선언한 calcPrice()메서드가 있고 이를 하위 클래스(VIPCustomer)에서 재정의한 상태에서 하위 클래스 인스턴스(vc)가 상위 클래스로 형변환이 되었음.
	 * 이떄 vc.calcPrice()가 호출되면, vc 변수를 선언할 때 사용한 자료형(Customer)의 메서드가 호출되는 것이 아니라 생성된 인스턴스(VIPCustomer)의 메서드가 호출됨. 이를 가상 메서드라고함. 자바의 모든 메서드는 가상메서드.
	 * 
	 * 
	 * 	08-4  다형성
	 * 
	 * 	다형성이란?
	 * 지금까지 설명한 묵시적 클래스 형 변환과 가상 메서드를 바탕으로 객체 지향의 중요한 특성인 다형성(polymorphism)을 학습하자.
	 * 다형성이란 하나의 코드가 여러 자료형으로 구현되어 실행되는 것을 말함. 쉽게 말해 같은 코드에서 여어 실행 결과가 나오는 것임.
	 * 
	 * 			   -------------Human 클래스	
	 * 			  |
	 * Amimal클래스-|-------------tiger 클래스
	 * 			  |
	 * 			   -------------Eagle 클래스
	 * 
	 * 위와 같이 3개의 크래스가 Animal 클래스를 상속받는 경우를 생각해보자. Animal 클래스에 메서드를 하나 정의하고 상속받은 클래스에서 재정의함. 이를 코드로 구현하면
	 * (polymorphism - AnimalTest.java)
	 * 
	 * 
	 * 
	 */
}
